<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_xattr.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_xattr.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsevents.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/utfconv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/xattr.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSByteOrder.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> shadow_sequence;

<span class="enscript-comment">/*
 * We use %p to prevent loss of precision for pointers on varying architectures.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SHADOW_NAME_FMT</span>		<span class="enscript-string">&quot;.vfs_rsrc_stream_%p%08x%p&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SHADOW_DIR_FMT</span>		<span class="enscript-string">&quot;.vfs_rsrc_streams_%p%x&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SHADOW_DIR_CONTAINER</span> <span class="enscript-string">&quot;/var/run&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAKE_SHADOW_NAME</span>(VP, NAME)  \
	snprintf((NAME), <span class="enscript-keyword">sizeof</span>((NAME)), (SHADOW_NAME_FMT), \
			((<span class="enscript-type">void</span>*)(VM_KERNEL_ADDRPERM(VP))), \
			(VP)-&gt;v_id, \
			((<span class="enscript-type">void</span>*)(VM_KERNEL_ADDRPERM((VP)-&gt;v_data))))

<span class="enscript-comment">/* The full path to the shadow directory */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAKE_SHADOW_DIRNAME</span>(VP, NAME)	\
	snprintf((NAME), <span class="enscript-keyword">sizeof</span>((NAME)), (SHADOW_DIR_CONTAINER <span class="enscript-string">&quot;/&quot;</span> SHADOW_DIR_FMT), \
			((<span class="enscript-type">void</span>*)(VM_KERNEL_ADDRPERM(VP))), shadow_sequence)

<span class="enscript-comment">/* The shadow directory as a 'leaf' entry */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAKE_SHADOW_DIR_LEAF</span>(VP, NAME)	\
	snprintf((NAME), <span class="enscript-keyword">sizeof</span>((NAME)), (SHADOW_DIR_FMT), \
			((<span class="enscript-type">void</span>*)(VM_KERNEL_ADDRPERM(VP))), shadow_sequence)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">default_getnamedstream</span>(vnode_t vp, vnode_t *svpp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">enum</span> nsoperation op, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">default_makenamedstream</span>(vnode_t vp, vnode_t *svpp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">default_removenamedstream</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">getshadowfile</span>(vnode_t vp, vnode_t *svpp, <span class="enscript-type">int</span> makestream, size_t *rsrcsize, <span class="enscript-type">int</span> *creator, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">get_shadow_dir</span>(vnode_t *sdvpp);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NAMEDSTREAMS */</span>

<span class="enscript-comment">/*
 * Default xattr support routines.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">default_getxattr</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uio_t uio, size_t *size, <span class="enscript-type">int</span> options,
    vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">default_setxattr</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uio_t uio, <span class="enscript-type">int</span> options,
    vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">default_listxattr</span>(vnode_t vp, uio_t uio, size_t *size, <span class="enscript-type">int</span> options,
    vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">default_removexattr</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> options,
    vfs_context_t context);

<span class="enscript-comment">/*
 *  Retrieve the data of an extended attribute.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_getxattr</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uio_t uio, size_t *size,
            <span class="enscript-type">int</span> options, vfs_context_t context)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (!XATTR_VNODE_SUPPORTED(vp)) {
		<span class="enscript-keyword">return</span> (EPERM);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-comment">/* getxattr calls are not allowed for streams. */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISNAMEDSTREAM) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Non-kernel request need extra checks performed.
	 *
	 * The XATTR_NOSECURITY flag implies a kernel request.
	 */</span>
	<span class="enscript-keyword">if</span> (!(options &amp; XATTR_NOSECURITY)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_vnode_check_getextattr(context, vp, name, uio);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>
		<span class="enscript-keyword">if</span> ((error = xattr_validatename(name))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> ((error = vnode_authorize(vp, NULL, KAUTH_VNODE_READ_EXTATTRIBUTES, context))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* The offset can only be non-zero for resource forks. */</span>
		<span class="enscript-keyword">if</span> (uio != NULL &amp;&amp; uio_offset(uio) != 0 &amp;&amp; 
		    bcmp(name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) != 0) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/* The offset can only be non-zero for resource forks. */</span>
	<span class="enscript-keyword">if</span> (uio != NULL &amp;&amp; uio_offset(uio) != 0 &amp;&amp; 
	    bcmp(name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) != 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = VNOP_GETXATTR(vp, name, uio, size, options, context);
	<span class="enscript-keyword">if</span> (error == ENOTSUP &amp;&amp; !(options &amp; XATTR_NODEFAULT)) {
		<span class="enscript-comment">/*
		 * A filesystem may keep some EAs natively and return ENOTSUP for others.
		 */</span>
		error = default_getxattr(vp, name, uio, size, options, context);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Set the data of an extended attribute.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_setxattr</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uio_t uio, <span class="enscript-type">int</span> options, vfs_context_t context)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (!XATTR_VNODE_SUPPORTED(vp)) {
		<span class="enscript-keyword">return</span> (EPERM);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-comment">/* setxattr calls are not allowed for streams. */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISNAMEDSTREAM) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((options &amp; (XATTR_REPLACE|XATTR_CREATE)) == (XATTR_REPLACE|XATTR_CREATE)) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> ((error = xattr_validatename(name))) {
		<span class="enscript-keyword">return</span> (error);
	}
 	<span class="enscript-keyword">if</span> (!(options &amp; XATTR_NOSECURITY)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_vnode_check_setextattr(context, vp, name, uio);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>
		error = vnode_authorize(vp, NULL, KAUTH_VNODE_WRITE_EXTATTRIBUTES, context);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* The offset can only be non-zero for resource forks. */</span>
	<span class="enscript-keyword">if</span> (uio_offset(uio) != 0 &amp;&amp; 
	    bcmp(name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) != 0 ) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = VNOP_SETXATTR(vp, name, uio, options, context);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DUAL_EAS</span>
	<span class="enscript-comment">/*
	 * An EJUSTRETURN is from a filesystem which keeps this xattr
	 * natively as well as in a dot-underscore file.  In this case the
	 * EJUSTRETURN means the filesytem has done nothing, but identifies the
	 * EA as one which may be represented natively and/or in a DU, and
	 * since XATTR_CREATE or XATTR_REPLACE was specified, only up here in
	 * in vn_setxattr can we do the getxattrs needed to ascertain whether
	 * the XATTR_{CREATE,REPLACE} should yield an error.
	 */</span>
	<span class="enscript-keyword">if</span> (error == EJUSTRETURN) {
		<span class="enscript-type">int</span> native = 0, dufile = 0;
		size_t sz;	<span class="enscript-comment">/* not used */</span>

		native = VNOP_GETXATTR(vp, name, NULL, &amp;sz, 0, context) ? 0 : 1;
		dufile = default_getxattr(vp, name, NULL, &amp;sz, 0, context) ? 0 : 1;
		<span class="enscript-keyword">if</span> (options &amp; XATTR_CREATE &amp;&amp; (native || dufile)) {
			error = EEXIST;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (options &amp; XATTR_REPLACE &amp;&amp; !(native || dufile)) {
			error = ENOATTR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/*
		 * Having determined no CREATE/REPLACE error should result, we
		 * zero those bits, so both backing stores get written to.
		 */</span>
		options &amp;= ~(XATTR_CREATE | XATTR_REPLACE);
		error = VNOP_SETXATTR(vp, name, uio, options, context);
		<span class="enscript-comment">/* the mainline path here is to have error==ENOTSUP ... */</span>
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUAL_EAS */</span>
	<span class="enscript-keyword">if</span> (error == ENOTSUP &amp;&amp; !(options &amp; XATTR_NODEFAULT)) {
		<span class="enscript-comment">/*
		 * A filesystem may keep some EAs natively and return ENOTSUP for others.
		 */</span>
		error = default_setxattr(vp, name, uio, options, context);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; !(options &amp; XATTR_NOSECURITY) &amp;&amp;
	    (vfs_flags(vnode_mount(vp)) &amp; MNT_MULTILABEL))
		mac_vnode_label_update_extattr(vnode_mount(vp), vp, name);
#<span class="enscript-reference">endif</span>
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Remove an extended attribute.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_removexattr</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name, <span class="enscript-type">int</span> options, vfs_context_t context)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (!XATTR_VNODE_SUPPORTED(vp)) {
		<span class="enscript-keyword">return</span> (EPERM);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-comment">/* removexattr calls are not allowed for streams. */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISNAMEDSTREAM) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((error = xattr_validatename(name))) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (!(options &amp; XATTR_NOSECURITY)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_vnode_check_deleteextattr(context, vp, name);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>
		error = vnode_authorize(vp, NULL, KAUTH_VNODE_WRITE_EXTATTRIBUTES, context);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	error = VNOP_REMOVEXATTR(vp, name, options, context);
	<span class="enscript-keyword">if</span> (error == ENOTSUP &amp;&amp; !(options &amp; XATTR_NODEFAULT)) {
		<span class="enscript-comment">/*
		 * A filesystem may keep some EAs natively and return ENOTSUP for others.
		 */</span>
		error = default_removexattr(vp, name, options, context);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DUAL_EAS</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == EJUSTRETURN) {
		<span class="enscript-comment">/*
		 * EJUSTRETURN is from a filesystem which keeps this xattr natively as well
		 * as in a dot-underscore file.  EJUSTRETURN means the filesytem did remove
		 * a native xattr, so failure to find it in a DU file during
		 * default_removexattr should not be considered an error.
		 */</span>
		error = default_removexattr(vp, name, options, context);
		<span class="enscript-keyword">if</span> (error == ENOATTR)
			error = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUAL_EAS */</span>
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; !(options &amp; XATTR_NOSECURITY) &amp;&amp;
	    (vfs_flags(vnode_mount(vp)) &amp; MNT_MULTILABEL))
		mac_vnode_label_update_extattr(vnode_mount(vp), vp, name);
#<span class="enscript-reference">endif</span>
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Retrieve the list of extended attribute names.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_listxattr</span>(vnode_t vp, uio_t uio, size_t *size, <span class="enscript-type">int</span> options, vfs_context_t context)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (!XATTR_VNODE_SUPPORTED(vp)) {
		<span class="enscript-keyword">return</span> (EPERM);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-comment">/* listxattr calls are not allowed for streams. */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISNAMEDSTREAM) {
		<span class="enscript-keyword">return</span> (EPERM);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (!(options &amp; XATTR_NOSECURITY)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_vnode_check_listextattr(context, vp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

		error = vnode_authorize(vp, NULL, KAUTH_VNODE_READ_EXTATTRIBUTES, context);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = VNOP_LISTXATTR(vp, uio, size, options, context);
	<span class="enscript-keyword">if</span> (error == ENOTSUP &amp;&amp; !(options &amp; XATTR_NODEFAULT)) {
		<span class="enscript-comment">/*
		 * A filesystem may keep some but not all EAs natively, in which case
		 * the native EA names will have been uiomove-d out (or *size updated)
		 * and the default_listxattr here will finish the job.  
		 */</span>
		error = default_listxattr(vp, uio, size, options, context);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">xattr_validatename</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	<span class="enscript-type">int</span> namelen;

	<span class="enscript-keyword">if</span> (name == NULL || name[0] == <span class="enscript-string">'\0'</span>) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	namelen = strnlen(name, XATTR_MAXNAMELEN);
	<span class="enscript-keyword">if</span> (name[namelen] != <span class="enscript-string">'\0'</span>) 
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);
	
	<span class="enscript-keyword">if</span> (utf8_validatestr((<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)name, namelen) != 0) 
		<span class="enscript-keyword">return</span> (EINVAL);
	
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Determine whether an EA is a protected system attribute.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">xattr_protected</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *attrname)
{
	<span class="enscript-keyword">return</span>(!strncmp(attrname, <span class="enscript-string">&quot;com.apple.system.&quot;</span>, 17));
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>

<span class="enscript-comment">/*
 * Obtain a named stream from vnode vp.
 */</span>
errno_t
<span class="enscript-function-name">vnode_getnamedstream</span>(vnode_t vp, vnode_t *svpp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">enum</span> nsoperation op, <span class="enscript-type">int</span> flags, vfs_context_t context)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_NAMED_STREAMS)
		error = VNOP_GETNAMEDSTREAM(vp, svpp, name, op, flags, context);
	<span class="enscript-keyword">else</span>
		error = default_getnamedstream(vp, svpp, name, op, context);

	<span class="enscript-keyword">if</span> (error == 0) {
		uint32_t streamflags = VISNAMEDSTREAM;
		vnode_t svp = *svpp;

		<span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_NAMED_STREAMS) == 0) {
			streamflags |= VISSHADOW;
		}
		
		<span class="enscript-comment">/* Tag the vnode. */</span>
		vnode_lock_spin(svp);
		svp-&gt;v_flag |= streamflags;
		vnode_unlock(svp);

		<span class="enscript-comment">/* Tag the parent so we know to flush credentials for streams on setattr */</span>
		vnode_lock_spin(vp);
		vp-&gt;v_lflag |= VL_HASSTREAMS;
		vnode_unlock(vp);

		<span class="enscript-comment">/* Make the file it's parent.  
		 * Note:  This parent link helps us distinguish vnodes for 
		 * shadow stream files from vnodes for resource fork on file 
		 * systems that support namedstream natively (both have 
		 * VISNAMEDSTREAM set) by allowing access to mount structure 
		 * for checking MNTK_NAMED_STREAMS bit at many places in the 
		 * code.
		 */</span>
		vnode_update_identity(svp, vp, NULL, 0, 0, VNODE_UPDATE_PARENT);
	}		

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Make a named stream for vnode vp.
 */</span>
errno_t 
<span class="enscript-function-name">vnode_makenamedstream</span>(vnode_t vp, vnode_t *svpp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> flags, vfs_context_t context)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_NAMED_STREAMS)
		error = VNOP_MAKENAMEDSTREAM(vp, svpp, name, flags, context);
	<span class="enscript-keyword">else</span>
		error = default_makenamedstream(vp, svpp, name, context);

	<span class="enscript-keyword">if</span> (error == 0) {
		uint32_t streamflags = VISNAMEDSTREAM;
		vnode_t svp = *svpp;

		<span class="enscript-comment">/* Tag the vnode. */</span>
		<span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_NAMED_STREAMS) == 0) {
			streamflags |= VISSHADOW;
		}
		
		<span class="enscript-comment">/* Tag the vnode. */</span>
		vnode_lock_spin(svp);
		svp-&gt;v_flag |= streamflags;
		vnode_unlock(svp);

		<span class="enscript-comment">/* Tag the parent so we know to flush credentials for streams on setattr */</span>
		vnode_lock_spin(vp);
		vp-&gt;v_lflag |= VL_HASSTREAMS;
		vnode_unlock(vp);

		<span class="enscript-comment">/* Make the file it's parent.
		 * Note:  This parent link helps us distinguish vnodes for 
		 * shadow stream files from vnodes for resource fork on file 
		 * systems that support namedstream natively (both have 
		 * VISNAMEDSTREAM set) by allowing access to mount structure 
		 * for checking MNTK_NAMED_STREAMS bit at many places in the 
		 * code.
		 */</span>
		vnode_update_identity(svp, vp, NULL, 0, 0, VNODE_UPDATE_PARENT);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Remove a named stream from vnode vp.
 */</span>
errno_t 
<span class="enscript-function-name">vnode_removenamedstream</span>(vnode_t vp, vnode_t svp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> flags, vfs_context_t context)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_NAMED_STREAMS)
		error = VNOP_REMOVENAMEDSTREAM(vp, svp, name, flags, context);
	<span class="enscript-keyword">else</span>
		error = default_removenamedstream(vp, name, context);

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NS_IOBUFSIZE</span>  (128 * 1024)

<span class="enscript-comment">/*
 * Release a named stream shadow file.
 *
 * Note: This function is called from two places where we do not need 
 * to check if the vnode has any references held before deleting the 
 * shadow file.  Once from vclean() when the vnode is being reclaimed 
 * and we do not hold any references on the vnode.  Second time from 
 * default_getnamedstream() when we get an error during shadow stream 
 * file initialization so that other processes who are waiting for the 
 * shadow stream file initialization by the creator will get opportunity 
 * to create and initialize the file again.
 */</span>
errno_t
<span class="enscript-function-name">vnode_relenamedstream</span>(vnode_t vp, vnode_t svp) {
	vnode_t dvp;
	<span class="enscript-type">struct</span> componentname cn;
	<span class="enscript-type">char</span> tmpname[80];
	errno_t err;
	
	<span class="enscript-comment">/* 
	 * We need to use the kernel context here.  If we used the supplied
	 * VFS context we have no clue whether or not it originated from userland
	 * where it could be subject to a chroot jail.  We need to ensure that all
	 * filesystem access to shadow files is done on the same FS regardless of
	 * userland process restrictions.
	 */</span>
	vfs_context_t kernelctx = vfs_context_kernel();

	cache_purge(svp);

	vnode_lock(svp);
	MAKE_SHADOW_NAME(vp, tmpname);
	vnode_unlock(svp);

	cn.cn_nameiop = DELETE;
	cn.cn_flags = ISLASTCN;
	cn.cn_context = kernelctx;
	cn.cn_pnbuf = tmpname;
	cn.cn_pnlen = <span class="enscript-keyword">sizeof</span>(tmpname);
	cn.cn_nameptr = cn.cn_pnbuf;
	cn.cn_namelen = strlen(tmpname);

	<span class="enscript-comment">/* 
	 * Obtain the vnode for the shadow files directory.  Make sure to 
	 * use the kernel ctx as described above.
	 */</span>
	err = get_shadow_dir(&amp;dvp);
	<span class="enscript-keyword">if</span> (err != 0) {
		<span class="enscript-keyword">return</span> err;
	}

	(<span class="enscript-type">void</span>) VNOP_REMOVE(dvp, svp, &amp;cn, 0, kernelctx);
	vnode_put(dvp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Flush a named stream shadow file.
 * 
 * 'vp' represents the AppleDouble file.
 * 'svp' represents the shadow file.
 */</span>
errno_t 
<span class="enscript-function-name">vnode_flushnamedstream</span>(vnode_t vp, vnode_t svp, vfs_context_t context)
{
	<span class="enscript-type">struct</span> vnode_attr va;
	uio_t auio = NULL;
	caddr_t  bufptr = NULL;
	size_t  bufsize = 0;
	size_t  offset;
	size_t  iosize;
	size_t datasize;
	<span class="enscript-type">int</span> error;
	<span class="enscript-comment">/* 
	 * The kernel context must be used for all I/O to the shadow file 
	 * and its namespace operations
	 */</span>
	vfs_context_t kernelctx = vfs_context_kernel();

	<span class="enscript-comment">/* The supplied context is used for access to the AD file itself */</span>

	VATTR_INIT(&amp;va);
	VATTR_WANTED(&amp;va, va_data_size);
	<span class="enscript-keyword">if</span> (VNOP_GETATTR(svp, &amp;va, context) != 0  ||
		!VATTR_IS_SUPPORTED(&amp;va, va_data_size)) {
		<span class="enscript-keyword">return</span> (0);
	}
	datasize = va.va_data_size;
	<span class="enscript-keyword">if</span> (datasize == 0) {
		(<span class="enscript-type">void</span>) default_removexattr(vp, XATTR_RESOURCEFORK_NAME, 0, context);
		<span class="enscript-keyword">return</span> (0);
	}

	iosize = bufsize = MIN(datasize, NS_IOBUFSIZE);
	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;bufptr, bufsize, VM_KERN_MEMORY_FILE)) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	auio = uio_create(1, 0, UIO_SYSSPACE, UIO_READ);
	offset = 0;

	<span class="enscript-comment">/*
	 * Copy the shadow stream file data into the resource fork.
	 */</span>
	error = VNOP_OPEN(svp, 0, kernelctx);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;vnode_flushnamedstream: err %d opening file\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">while</span> (offset &lt; datasize) {
		iosize = MIN(datasize - offset, iosize);

		uio_reset(auio, offset, UIO_SYSSPACE, UIO_READ);
		uio_addiov(auio, (uintptr_t)bufptr, iosize);
		error = VNOP_READ(svp, auio, 0, kernelctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* Since there's no truncate xattr we must remove the resource fork. */</span>
		<span class="enscript-keyword">if</span> (offset == 0) {
			error = default_removexattr(vp, XATTR_RESOURCEFORK_NAME, 0, context);
			<span class="enscript-keyword">if</span> ((error != 0) &amp;&amp; (error != ENOATTR)) {
				<span class="enscript-keyword">break</span>;
			}
		}
		uio_reset(auio, offset, UIO_SYSSPACE, UIO_WRITE);
		uio_addiov(auio, (uintptr_t)bufptr, iosize);
		error = vn_setxattr(vp, XATTR_RESOURCEFORK_NAME, auio, XATTR_NOSECURITY, context);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">break</span>;
		}
		offset += iosize;
	}

	<span class="enscript-comment">/* close shadowfile */</span>
	(<span class="enscript-type">void</span>) VNOP_CLOSE(svp, 0, kernelctx);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (bufptr) {
		kmem_free(kernel_map, (vm_offset_t)bufptr, bufsize);
	}
	<span class="enscript-keyword">if</span> (auio) {
		uio_free(auio);
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/* 
 * Verify that the vnode 'vp' is a vnode that lives in the shadow
 * directory.  We can't just query the parent pointer directly since
 * the shadowfile is hooked up to the actual file it's a stream for.
 */</span>
errno_t <span class="enscript-function-name">vnode_verifynamedstream</span>(vnode_t vp) {
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> vnode *shadow_dvp = NULL;
	<span class="enscript-type">struct</span> vnode *shadowfile = NULL;
	<span class="enscript-type">struct</span> componentname cn;
	
	<span class="enscript-comment">/* 
	 * We need to use the kernel context here.  If we used the supplied
	 * VFS context we have no clue whether or not it originated from userland
	 * where it could be subject to a chroot jail.  We need to ensure that all
	 * filesystem access to shadow files is done on the same FS regardless of
	 * userland process restrictions.
	 */</span>
	vfs_context_t kernelctx = vfs_context_kernel();
	<span class="enscript-type">char</span> tmpname[80];
	

	<span class="enscript-comment">/* Get the shadow directory vnode */</span>
	error = get_shadow_dir(&amp;shadow_dvp);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-comment">/* Re-generate the shadow name in the buffer */</span>
	MAKE_SHADOW_NAME (vp, tmpname);

	<span class="enscript-comment">/* Look up item in shadow dir */</span>
	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameiop = LOOKUP;
	cn.cn_flags = ISLASTCN | CN_ALLOWRSRCFORK;
	cn.cn_context = kernelctx;
	cn.cn_pnbuf = tmpname;
	cn.cn_pnlen = <span class="enscript-keyword">sizeof</span>(tmpname);
	cn.cn_nameptr = cn.cn_pnbuf;
	cn.cn_namelen = strlen(tmpname);

	<span class="enscript-keyword">if</span> (VNOP_LOOKUP (shadow_dvp, &amp;shadowfile, &amp;cn, kernelctx) == 0) {
		<span class="enscript-comment">/* is the pointer the same? */</span>
		<span class="enscript-keyword">if</span> (shadowfile == vp) {
			error = 0;	
		}
		<span class="enscript-keyword">else</span> {
			error = EPERM;
		}
		<span class="enscript-comment">/* drop the iocount acquired */</span>
		vnode_put (shadowfile);
	}	

	<span class="enscript-comment">/* Drop iocount on shadow dir */</span>
	vnode_put (shadow_dvp);
	<span class="enscript-keyword">return</span> error;
}	

<span class="enscript-comment">/* 
 * Access or create the shadow file as needed. 
 * 
 * 'makestream' with non-zero value means that we need to guarantee we were the
 * creator of the shadow file.
 *
 * 'context' is the user supplied context for the original VFS operation that
 * caused us to need a shadow file.
 *
 * int pointed to by 'creator' is nonzero if we created the shadowfile.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getshadowfile</span>(vnode_t vp, vnode_t *svpp, <span class="enscript-type">int</span> makestream, size_t *rsrcsize,
              <span class="enscript-type">int</span> *creator, vfs_context_t context)
{
	vnode_t  dvp = NULLVP;
	vnode_t  svp = NULLVP;
	<span class="enscript-type">struct</span> componentname cn;
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">char</span> tmpname[80];
	size_t datasize = 0;
	<span class="enscript-type">int</span>  error = 0;
	<span class="enscript-type">int</span> retries = 0;
	vfs_context_t kernelctx = vfs_context_kernel();

<span class="enscript-reference">retry_create</span>:
	*creator = 0;
	<span class="enscript-comment">/* Establish a unique file name. */</span>
	MAKE_SHADOW_NAME(vp, tmpname);
	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameiop = LOOKUP;
	cn.cn_flags = ISLASTCN;
	cn.cn_context = context;
	cn.cn_pnbuf = tmpname;
	cn.cn_pnlen = <span class="enscript-keyword">sizeof</span>(tmpname);
	cn.cn_nameptr = cn.cn_pnbuf;
	cn.cn_namelen = strlen(tmpname);

	<span class="enscript-comment">/* Pick up uid, gid, mode and date from original file. */</span>
	VATTR_INIT(&amp;va);
	VATTR_WANTED(&amp;va, va_uid);
	VATTR_WANTED(&amp;va, va_gid);
	VATTR_WANTED(&amp;va, va_mode);
	VATTR_WANTED(&amp;va, va_create_time);
	VATTR_WANTED(&amp;va, va_modify_time);
	<span class="enscript-keyword">if</span> (VNOP_GETATTR(vp, &amp;va, context) != 0  ||
		!VATTR_IS_SUPPORTED(&amp;va, va_uid)  ||
		!VATTR_IS_SUPPORTED(&amp;va, va_gid)  ||
		!VATTR_IS_SUPPORTED(&amp;va, va_mode)) {
		va.va_uid = KAUTH_UID_NONE;
		va.va_gid = KAUTH_GID_NONE;
		va.va_mode = S_IRUSR | S_IWUSR;
	}
	va.va_vaflags = VA_EXCLUSIVE;
	VATTR_SET(&amp;va, va_type, VREG);
	<span class="enscript-comment">/* We no longer change the access, but we still hide it. */</span>
	VATTR_SET(&amp;va, va_flags, UF_HIDDEN);

	<span class="enscript-comment">/* Obtain the vnode for the shadow files directory. */</span>
	<span class="enscript-keyword">if</span> (get_shadow_dir(&amp;dvp) != 0) {
		error = ENOTDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (!makestream) {
		<span class="enscript-comment">/* See if someone else already has it open. */</span>
		<span class="enscript-keyword">if</span> (VNOP_LOOKUP(dvp, &amp;svp, &amp;cn, kernelctx) == 0) {
			<span class="enscript-comment">/* Double check existence by asking for size. */</span>
			VATTR_INIT(&amp;va);
			VATTR_WANTED(&amp;va, va_data_size);
			<span class="enscript-keyword">if</span> (VNOP_GETATTR(svp, &amp;va, context) == 0  &amp;&amp;
			    VATTR_IS_SUPPORTED(&amp;va, va_data_size)) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;  <span class="enscript-comment">/* OK to use. */</span>
			}
		}
		
		<span class="enscript-comment">/* 
		 * Otherwise make sure the resource fork data exists. 
		 * Use the supplied context for accessing the AD file.
		 */</span>
		error = vn_getxattr(vp, XATTR_RESOURCEFORK_NAME, NULL, &amp;datasize,
		                    XATTR_NOSECURITY, context);
		<span class="enscript-comment">/*
		 * To maintain binary compatibility with legacy Carbon
		 * emulated resource fork support, if the resource fork
		 * doesn't exist but the Finder Info does,  then act as
		 * if an empty resource fork is present (see 4724359).
		 */</span>
		<span class="enscript-keyword">if</span> ((error == ENOATTR) &amp;&amp;
		    (vn_getxattr(vp, XATTR_FINDERINFO_NAME, NULL, &amp;datasize,
		                 XATTR_NOSECURITY, context) == 0)) {
			datasize = 0;
			error = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
	
			<span class="enscript-comment">/* If the resource fork exists, its size is expected to be non-zero. */</span>
			<span class="enscript-keyword">if</span> (datasize == 0) {
				error = ENOATTR;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}
	<span class="enscript-comment">/* Create the shadow stream file. */</span>
	error = VNOP_CREATE(dvp, &amp;svp, &amp;cn, &amp;va, kernelctx);
	<span class="enscript-keyword">if</span> (error == 0) {
		vnode_recycle(svp);
		*creator = 1;
	} 
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error == EEXIST) &amp;&amp; !makestream) {
		error = VNOP_LOOKUP(dvp, &amp;svp, &amp;cn, kernelctx);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error == ENOENT) &amp;&amp; !makestream) {
		<span class="enscript-comment">/*
		 * We could have raced with a rmdir on the shadow directory
		 * post-lookup.  Retry from the beginning, 1x only, to
		 * try and see if we need to re-create the shadow directory	
		 * in get_shadow_dir.
		 */</span>
		<span class="enscript-keyword">if</span> (retries == 0) {
			retries++;
			<span class="enscript-keyword">if</span> (dvp) {
				vnode_put (dvp);
				dvp = NULLVP;
			}
			<span class="enscript-keyword">if</span> (svp) {
				vnode_put (svp);
				svp = NULLVP;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry_create</span>;
		}
		<span class="enscript-comment">/* Otherwise, just error out normally below */</span>
	}
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (dvp) {
		vnode_put(dvp);
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* On errors, clean up shadow stream file. */</span>
		<span class="enscript-keyword">if</span> (svp) {
			vnode_put(svp);
			svp = NULLVP;
		}
	}
	*svpp = svp;
	<span class="enscript-keyword">if</span> (rsrcsize) {
		*rsrcsize = datasize;
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_getnamedstream</span>(vnode_t vp, vnode_t *svpp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">enum</span> nsoperation op, vfs_context_t context)
{
	vnode_t  svp = NULLVP;
	uio_t auio = NULL;
	caddr_t  bufptr = NULL;
	size_t  bufsize = 0;
	size_t  datasize = 0;
	<span class="enscript-type">int</span>  creator;
	<span class="enscript-type">int</span>  error;

	<span class="enscript-comment">/* need the kernel context for accessing the shadowfile */</span>
	vfs_context_t kernelctx = vfs_context_kernel();

	<span class="enscript-comment">/*
	 * Only the &quot;com.apple.ResourceFork&quot; stream is supported here.
	 */</span>
	<span class="enscript-keyword">if</span> (bcmp(name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) != 0) {
		*svpp = NULLVP;
		<span class="enscript-keyword">return</span> (ENOATTR);
	}
<span class="enscript-reference">retry</span>:
	<span class="enscript-comment">/*
	 * Obtain a shadow file for the resource fork I/O.
	 * 
	 * Need to pass along the supplied context so that getshadowfile
	 * can access the AD file as needed, using it.
	 */</span>
	error = getshadowfile(vp, &amp;svp, 0, &amp;datasize, &amp;creator, context);
	<span class="enscript-keyword">if</span> (error) {
		*svpp = NULLVP;
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/*
	 * The creator of the shadow file provides its file data,
	 * all other threads should wait until its ready.  In order to 
	 * prevent a deadlock during error codepaths, we need to check if the
	 * vnode is being created, or if it has failed out. Regardless of success or 
	 * failure, we set the VISSHADOW bit on the vnode, so we check that
	 * if the vnode's flags don't have VISNAMEDSTREAM set.  If it doesn't,
	 * then we can infer the creator isn't done yet.  If it's there, but
	 * VISNAMEDSTREAM is not set, then we can infer it errored out and we should
	 * try again.
	 */</span>
	<span class="enscript-keyword">if</span> (!creator) {
		vnode_lock(svp);
		<span class="enscript-keyword">if</span> (svp-&gt;v_flag &amp; VISNAMEDSTREAM) {
			<span class="enscript-comment">/* data is ready, go use it */</span>
			vnode_unlock(svp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* It's not ready, wait for it (sleep using v_parent as channel) */</span>
			<span class="enscript-keyword">if</span> ((svp-&gt;v_flag &amp; VISSHADOW)) {
				<span class="enscript-comment">/* 
				 * No VISNAMEDSTREAM, but we did see VISSHADOW, indicating that the other
				 * thread is done with this vnode. Just unlock the vnode and try again
				 */</span>
				vnode_unlock(svp);
			}	
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Otherwise, sleep if the shadow file is not created yet */</span>
				msleep((caddr_t)&amp;svp-&gt;v_parent, &amp;svp-&gt;v_lock, PINOD | PDROP,
						<span class="enscript-string">&quot;getnamedstream&quot;</span>, NULL);
			}
			vnode_put(svp);
			svp = NULLVP;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Copy the real resource fork data into shadow stream file.
	 */</span>
	<span class="enscript-keyword">if</span> (op == NS_OPEN &amp;&amp; datasize != 0) {
		size_t  offset;
        	size_t  iosize;

		iosize = bufsize = MIN(datasize, NS_IOBUFSIZE);
		<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;bufptr, bufsize, VM_KERN_MEMORY_FILE)) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		auio = uio_create(1, 0, UIO_SYSSPACE, UIO_READ);
		offset = 0;

		<span class="enscript-comment">/* open the shadow file */</span>
		error = VNOP_OPEN(svp, 0, kernelctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">while</span> (offset &lt; datasize) {
			size_t	tmpsize;

			iosize = MIN(datasize - offset, iosize);

			uio_reset(auio, offset, UIO_SYSSPACE, UIO_READ);
			uio_addiov(auio, (uintptr_t)bufptr, iosize);
			<span class="enscript-comment">/* use supplied ctx for AD file */</span>
			error = vn_getxattr(vp, XATTR_RESOURCEFORK_NAME, auio, &amp;tmpsize,
			                    XATTR_NOSECURITY, context);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">break</span>;
			}
		
			uio_reset(auio, offset, UIO_SYSSPACE, UIO_WRITE);
			uio_addiov(auio, (uintptr_t)bufptr, iosize);
			<span class="enscript-comment">/* kernel context for writing shadowfile */</span>
			error = VNOP_WRITE(svp, auio, 0, kernelctx);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">break</span>;
			}
			offset += iosize;
		}

		<span class="enscript-comment">/* close shadow file */</span>
		(<span class="enscript-type">void</span>) VNOP_CLOSE(svp, 0, kernelctx);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* Wake up anyone waiting for svp file content */</span>
	<span class="enscript-keyword">if</span> (creator) {
		<span class="enscript-keyword">if</span> (error == 0) {
			vnode_lock(svp);
			<span class="enscript-comment">/* VISSHADOW would be set later on anyway, so we set it now */</span>
			svp-&gt;v_flag |= (VISNAMEDSTREAM | VISSHADOW);
			wakeup((caddr_t)&amp;svp-&gt;v_parent);
			vnode_unlock(svp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* On post create errors, get rid of the shadow file.  This 
			 * way if there is another process waiting for initialization 
			 * of the shadowfile by the current process will wake up and 
			 * retry by creating and initializing the shadow file again.
			 * Also add the VISSHADOW bit here to indicate we're done operating
			 * on this vnode.
			 */</span>
			(<span class="enscript-type">void</span>)vnode_relenamedstream(vp, svp);
			vnode_lock (svp);
			svp-&gt;v_flag |= VISSHADOW;
			wakeup((caddr_t)&amp;svp-&gt;v_parent);
			vnode_unlock(svp);
		}
	}

	<span class="enscript-keyword">if</span> (bufptr) {
		kmem_free(kernel_map, (vm_offset_t)bufptr, bufsize);
	}
	<span class="enscript-keyword">if</span> (auio) {
		uio_free(auio);
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* On errors, clean up shadow stream file. */</span>
		<span class="enscript-keyword">if</span> (svp) {
			vnode_put(svp);
			svp = NULLVP;
		}
	}
	*svpp = svp;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_makenamedstream</span>(vnode_t vp, vnode_t *svpp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, vfs_context_t context)
{
	<span class="enscript-type">int</span> creator;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Only the &quot;com.apple.ResourceFork&quot; stream is supported here.
	 */</span>
	<span class="enscript-keyword">if</span> (bcmp(name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) != 0) {
		*svpp = NULLVP;
		<span class="enscript-keyword">return</span> (ENOATTR);
	}

	<span class="enscript-comment">/* Supply the context to getshadowfile so it can manipulate the AD file */</span>
	error = getshadowfile(vp, svpp, 1, NULL, &amp;creator, context);

	<span class="enscript-comment">/*
	 * Wake up any waiters over in default_getnamedstream().
	 */</span>
	<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; (*svpp != NULL) &amp;&amp; creator) {
		vnode_t svp = *svpp;

		vnode_lock(svp);
		<span class="enscript-comment">/* If we're the creator, mark it as a named stream */</span>
		svp-&gt;v_flag |= (VISNAMEDSTREAM | VISSHADOW);
		<span class="enscript-comment">/* Wakeup any waiters on the v_parent channel */</span>
		wakeup((caddr_t)&amp;svp-&gt;v_parent);
		vnode_unlock(svp);

	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">default_removenamedstream</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, vfs_context_t context)
{
	<span class="enscript-comment">/*
	 * Only the &quot;com.apple.ResourceFork&quot; stream is supported here.
	 */</span>
	<span class="enscript-keyword">if</span> (bcmp(name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) != 0) {
		<span class="enscript-keyword">return</span> (ENOATTR);
	}
	<span class="enscript-comment">/*
	 * XXX - what about other opened instances?
	 */</span>
	<span class="enscript-keyword">return</span> default_removexattr(vp, XATTR_RESOURCEFORK_NAME, 0, context);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">get_shadow_dir</span>(vnode_t *sdvpp) {
	vnode_t  dvp = NULLVP;
	vnode_t  sdvp = NULLVP;
	<span class="enscript-type">struct</span> componentname  cn;
	<span class="enscript-type">struct</span> vnode_attr  va;
	<span class="enscript-type">char</span> tmpname[80];
	uint32_t  tmp_fsid;
	<span class="enscript-type">int</span>  error;
	vfs_context_t kernelctx = vfs_context_kernel();

	bzero(tmpname, <span class="enscript-keyword">sizeof</span>(tmpname));
	MAKE_SHADOW_DIRNAME(rootvnode, tmpname);
	<span class="enscript-comment">/* 
	 * Look up the shadow directory to ensure that it still exists. 
	 * By looking it up, we get an iocounted dvp to use, and avoid some coherency issues
	 * in caching it when multiple threads may be trying to manipulate the pointers.
	 * 
	 * Make sure to use the kernel context.  We want a singular view of
	 * the shadow dir regardless of chrooted processes.
	 */</span>
	error = vnode_lookup(tmpname, 0, &amp;sdvp, kernelctx);
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/*
		 * If we get here, then we have successfully looked up the shadow dir, 
		 * and it has an iocount from the lookup. Return the vp in the output argument.
		 */</span>
		*sdvpp = sdvp;
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-comment">/* In the failure case, no iocount is acquired */</span>
	sdvp = NULLVP;
	bzero (tmpname, <span class="enscript-keyword">sizeof</span>(tmpname));

	<span class="enscript-comment">/* 
	 * Obtain the vnode for &quot;/var/run&quot; directory using the kernel
	 * context.
	 *
	 * This is defined in the SHADOW_DIR_CONTAINER macro
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_lookup(SHADOW_DIR_CONTAINER, 0, &amp;dvp, kernelctx) != 0) {
		error = ENOTSUP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* 
	 * Create the shadow stream directory.
	 * 'dvp' below suggests the parent directory so 
	 * we only need to provide the leaf entry name
	 */</span>
	MAKE_SHADOW_DIR_LEAF(rootvnode, tmpname);
	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameiop = LOOKUP;
	cn.cn_flags = ISLASTCN;
	cn.cn_context = kernelctx;
	cn.cn_pnbuf = tmpname;
	cn.cn_pnlen = <span class="enscript-keyword">sizeof</span>(tmpname);
	cn.cn_nameptr = cn.cn_pnbuf;
	cn.cn_namelen = strlen(tmpname);

	<span class="enscript-comment">/*
	 * owned by root, only readable by root, hidden
	 */</span>
	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_uid, 0);
	VATTR_SET(&amp;va, va_gid, 0);
	VATTR_SET(&amp;va, va_mode, S_IRUSR | S_IXUSR);
	VATTR_SET(&amp;va, va_type, VDIR);
	VATTR_SET(&amp;va, va_flags, UF_HIDDEN);
	va.va_vaflags = VA_EXCLUSIVE;

	error = VNOP_MKDIR(dvp, &amp;sdvp, &amp;cn, &amp;va, kernelctx);
	
	<span class="enscript-comment">/*
	 * There can be only one winner for an exclusive create.
	 */</span>
	<span class="enscript-keyword">if</span> (error == EEXIST) {
		<span class="enscript-comment">/* loser has to look up directory */</span>
		error = VNOP_LOOKUP(dvp, &amp;sdvp, &amp;cn, kernelctx);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-comment">/* Make sure its in fact a directory */</span>
			<span class="enscript-keyword">if</span> (sdvp-&gt;v_type != VDIR) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">baddir</span>;
			}
			<span class="enscript-comment">/* Obtain the fsid for /var/run directory */</span>
			VATTR_INIT(&amp;va);
			VATTR_WANTED(&amp;va, va_fsid);
			<span class="enscript-keyword">if</span> (VNOP_GETATTR(dvp, &amp;va, kernelctx) != 0  ||
			    !VATTR_IS_SUPPORTED(&amp;va, va_fsid)) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">baddir</span>;
			}
			tmp_fsid = va.va_fsid;

			VATTR_INIT(&amp;va);
			VATTR_WANTED(&amp;va, va_uid);
			VATTR_WANTED(&amp;va, va_gid);
			VATTR_WANTED(&amp;va, va_mode);
			VATTR_WANTED(&amp;va, va_fsid);
			VATTR_WANTED(&amp;va, va_dirlinkcount);
			VATTR_WANTED(&amp;va, va_acl);
			<span class="enscript-comment">/* Provide defaults for attrs that may not be supported */</span>
			va.va_dirlinkcount = 1;
			va.va_acl = (kauth_acl_t) KAUTH_FILESEC_NONE;

			<span class="enscript-keyword">if</span> (VNOP_GETATTR(sdvp, &amp;va, kernelctx) != 0  ||
			    !VATTR_IS_SUPPORTED(&amp;va, va_uid)  ||
			    !VATTR_IS_SUPPORTED(&amp;va, va_gid)  ||
			    !VATTR_IS_SUPPORTED(&amp;va, va_mode)  ||
			    !VATTR_IS_SUPPORTED(&amp;va, va_fsid)) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">baddir</span>;
			}
			<span class="enscript-comment">/*
			 * Make sure its what we want: 
			 * 	- owned by root
			 *	- not writable by anyone
			 *	- on same file system as /var/run
			 *	- not a hard-linked directory
			 *	- no ACLs (they might grant write access)
			 */</span>
			<span class="enscript-keyword">if</span> ((va.va_uid != 0) || (va.va_gid != 0) ||
			    (va.va_mode &amp; (S_IWUSR | S_IRWXG | S_IRWXO)) ||
			    (va.va_fsid != tmp_fsid) ||
			    (va.va_dirlinkcount != 1) ||
			     (va.va_acl != (kauth_acl_t) KAUTH_FILESEC_NONE)) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">baddir</span>;
			}
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (dvp) {
		vnode_put(dvp);
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* On errors, clean up shadow stream directory. */</span>
		<span class="enscript-keyword">if</span> (sdvp) {
			vnode_put(sdvp);
			sdvp = NULLVP;
		}
	}
	*sdvpp = sdvp;
	<span class="enscript-keyword">return</span> (error);

<span class="enscript-reference">baddir</span>:
	<span class="enscript-comment">/* This is not the dir we're looking for, move along */</span>
	++shadow_sequence;  <span class="enscript-comment">/* try something else next time */</span>
	error = ENOTDIR;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NAMEDSTREAMS */</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
<span class="enscript-comment">/*
 * Default Implementation (Non-native EA) 
 */</span>


<span class="enscript-comment">/*
   Typical &quot;._&quot; AppleDouble Header File layout:
  ------------------------------------------------------------
         MAGIC          0x00051607
         VERSION        0x00020000
         FILLER         0
         COUNT          2
     .-- AD ENTRY[0]    Finder Info Entry (must be first)
  .--+-- AD ENTRY[1]    Resource Fork Entry (must be last)
  |  '-&gt; FINDER INFO
  |      /////////////  Fixed Size Data (32 bytes)
  |      EXT ATTR HDR
  |      /////////////
  |      ATTR ENTRY[0] --.
  |      ATTR ENTRY[1] --+--.
  |      ATTR ENTRY[2] --+--+--.
  |         ...          |  |  |
  |      ATTR ENTRY[N] --+--+--+--.
  |      ATTR DATA 0   &lt;-'  |  |  |
  |      ////////////       |  |  |
  |      ATTR DATA 1   &lt;----'  |  |
  |      /////////////         |  |
  |      ATTR DATA 2   &lt;-------'  |
  |      /////////////            |
  |         ...                   |
  |      ATTR DATA N   &lt;----------'
  |      /////////////
  |                      Attribute Free Space
  |
  '----&gt; RESOURCE FORK
         /////////////   Variable Sized Data
         /////////////
         /////////////
         /////////////
         /////////////
         /////////////
            ...
         /////////////
 
  ------------------------------------------------------------

   NOTE: The EXT ATTR HDR, ATTR ENTRY's and ATTR DATA's are
   stored as part of the Finder Info.  The length in the Finder
   Info AppleDouble entry includes the length of the extended
   attribute header, attribute entries, and attribute data.
*/</span>


<span class="enscript-comment">/*
 * On Disk Data Structures
 *
 * Note: Motorola 68K alignment and big-endian.
 *
 * See RFC 1740 for additional information about the AppleDouble file format.
 *
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ADH_MAGIC</span>     0x00051607
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ADH_VERSION</span>   0x00020000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ADH_MACOSX</span>    <span class="enscript-string">&quot;Mac OS X        &quot;</span>

<span class="enscript-comment">/*
 * AppleDouble Entry ID's
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_DATA</span>          1   <span class="enscript-comment">/* Data fork */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_RESOURCE</span>      2   <span class="enscript-comment">/* Resource fork */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_REALNAME</span>      3   <span class="enscript-comment">/* Files name on home file system */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_COMMENT</span>       4   <span class="enscript-comment">/* Standard Mac comment */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_ICONBW</span>        5   <span class="enscript-comment">/* Mac black &amp; white icon */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_ICONCOLOR</span>     6   <span class="enscript-comment">/* Mac color icon */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_UNUSED</span>        7   <span class="enscript-comment">/* Not used */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_FILEDATES</span>     8   <span class="enscript-comment">/* File dates; create, modify, etc */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_FINDERINFO</span>    9   <span class="enscript-comment">/* Mac Finder info &amp; extended info */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_MACINFO</span>      10   <span class="enscript-comment">/* Mac file info, attributes, etc */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_PRODOSINFO</span>   11   <span class="enscript-comment">/* Pro-DOS file info, attrib., etc */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_MSDOSINFO</span>    12   <span class="enscript-comment">/* MS-DOS file info, attributes, etc */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_AFPNAME</span>      13   <span class="enscript-comment">/* Short name on AFP server */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_AFPINFO</span>      14   <span class="enscript-comment">/* AFP file info, attrib., etc */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_AFPDIRID</span>     15   <span class="enscript-comment">/* AFP directory ID */</span> 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_ATTRIBUTES</span>   AD_FINDERINFO


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_FILE_PREFIX</span>   <span class="enscript-string">&quot;._&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_HDR_MAGIC</span>     0x41545452   <span class="enscript-comment">/* 'ATTR' */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_BUF_SIZE</span>      4096        <span class="enscript-comment">/* default size of the attr file and how much we'll grow by */</span>

<span class="enscript-comment">/* Implementation Limits */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_MAX_SIZE</span>      AD_XATTR_MAXSIZE
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_MAX_HDR_SIZE</span>  65536
<span class="enscript-comment">/*
 * Note: ATTR_MAX_HDR_SIZE is the largest attribute header
 * size supported (including the attribute entries). All of
 * the attribute entries must reside within this limit.  If
 * any of the attribute data crosses the ATTR_MAX_HDR_SIZE
 * boundry, then all of the attribute data I/O is performed
 * separately from the attribute header I/O.
 *
 * In particular, all of the attr_entry structures must lie
 * completely within the first ATTR_MAX_HDR_SIZE bytes of the
 * AppleDouble file.  However, the attribute data (i.e. the
 * contents of the extended attributes) may extend beyond the
 * first ATTR_MAX_HDR_SIZE bytes of the file.  Note that this
 * limit is to allow the implementation to optimize by reading
 * the first ATTR_MAX_HDR_SIZE bytes of the file.
 */</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FINDERINFOSIZE</span>	32

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> apple_double_entry {
	u_int32_t   type;     <span class="enscript-comment">/* entry type: see list, 0 invalid */</span> 
	u_int32_t   offset;   <span class="enscript-comment">/* entry data offset from the beginning of the file. */</span>
 	u_int32_t   length;   <span class="enscript-comment">/* entry data length in bytes. */</span>
} __attribute__((aligned(2), packed)) apple_double_entry_t;


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> apple_double_header {
	u_int32_t   magic;         <span class="enscript-comment">/* == ADH_MAGIC */</span>
	u_int32_t   version;       <span class="enscript-comment">/* format version: 2 = 0x00020000 */</span> 
	u_int32_t   filler[4];
	u_int16_t   numEntries;	   <span class="enscript-comment">/* number of entries which follow */</span> 
	apple_double_entry_t   entries[2];  <span class="enscript-comment">/* 'finfo' &amp; 'rsrc' always exist */</span>
	u_int8_t    finfo[FINDERINFOSIZE];  <span class="enscript-comment">/* Must start with Finder Info (32 bytes) */</span>
	u_int8_t    pad[2];        <span class="enscript-comment">/* get better alignment inside attr_header */</span>
} __attribute__((aligned(2), packed)) apple_double_header_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ADHDRSIZE</span>  (4+4+16+2)

<span class="enscript-comment">/* Entries are aligned on 4 byte boundaries */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> attr_entry {
	u_int32_t   offset;     <span class="enscript-comment">/* file offset to data */</span>
	u_int32_t   length;     <span class="enscript-comment">/* size of attribute data */</span>
	u_int16_t   flags;
	u_int8_t    namelen;
	u_int8_t    name[1];    <span class="enscript-comment">/* NULL-terminated UTF-8 name (up to 128 bytes max) */</span>
} __attribute__((aligned(2), packed)) attr_entry_t;


<span class="enscript-comment">/* Header + entries must fit into 64K.  Data may extend beyond 64K. */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> attr_header {
	apple_double_header_t  appledouble;
	u_int32_t   magic;        <span class="enscript-comment">/* == ATTR_HDR_MAGIC */</span>
	u_int32_t   debug_tag;    <span class="enscript-comment">/* for debugging == file id of owning file */</span>
	u_int32_t   total_size;   <span class="enscript-comment">/* file offset of end of attribute header + entries + data */</span> 
	u_int32_t   data_start;   <span class="enscript-comment">/* file offset to attribute data area */</span>
	u_int32_t   data_length;  <span class="enscript-comment">/* length of attribute data area */</span>
	u_int32_t   reserved[3];
	u_int16_t   flags;
	u_int16_t   num_attrs;
} __attribute__((aligned(2), packed)) attr_header_t;


<span class="enscript-comment">/* Empty Resource Fork Header */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> rsrcfork_header {
	u_int32_t    fh_DataOffset;
	u_int32_t    fh_MapOffset;
	u_int32_t    fh_DataLength;
	u_int32_t    fh_MapLength;
	u_int8_t     systemData[112];
	u_int8_t     appData[128];
	u_int32_t    mh_DataOffset;
	u_int32_t    mh_MapOffset;
	u_int32_t    mh_DataLength;
	u_int32_t    mh_MapLength;
	u_int32_t    mh_Next;
	u_int16_t    mh_RefNum;
	u_int8_t     mh_Attr;
	u_int8_t     mh_InMemoryAttr;
	u_int16_t    mh_Types;
	u_int16_t    mh_Names;
	u_int16_t    typeCount;
} __attribute__((aligned(2), packed)) rsrcfork_header_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RF_FIRST_RESOURCE</span>    256
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RF_NULL_MAP_LENGTH</span>    30
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RF_EMPTY_TAG</span>  <span class="enscript-string">&quot;This resource fork intentionally left blank   &quot;</span>

<span class="enscript-comment">/* Runtime information about the attribute file. */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> attr_info {
	vfs_context_t          context;
	vnode_t                filevp;
	size_t                 filesize;
	size_t                 iosize;
	u_int8_t               *rawdata;
	size_t                 rawsize;  <span class="enscript-comment">/* minimum of filesize or ATTR_MAX_HDR_SIZE */</span>
	apple_double_header_t  *filehdr;
	apple_double_entry_t   *finderinfo;
	apple_double_entry_t   *rsrcfork;
	attr_header_t          *attrhdr;
	attr_entry_t           *attr_entry;
	u_int8_t               readonly;
	u_int8_t               emptyfinderinfo;
} attr_info_t;


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_SETTING</span>  1

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_ALIGN</span> 3L  <span class="enscript-comment">/* Use four-byte alignment */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_ENTRY_LENGTH</span>(namelen)  \
        ((<span class="enscript-keyword">sizeof</span>(attr_entry_t) - 1 + (namelen) + ATTR_ALIGN) &amp; (~ATTR_ALIGN))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_NEXT</span>(ae)  \
	 (attr_entry_t *)((u_int8_t *)(ae) + ATTR_ENTRY_LENGTH((ae)-&gt;namelen))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_VALID</span>(ae, ai)  \
	((u_int8_t *)ATTR_NEXT(ae) &lt;= ((ai).rawdata + (ai).rawsize))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SWAP16</span>(x)  OSSwapBigToHostInt16((x))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SWAP32</span>(x)  OSSwapBigToHostInt32((x))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SWAP64</span>(x)  OSSwapBigToHostInt64((x))


<span class="enscript-type">static</span> u_int32_t emptyfinfo[8] = {0};


<span class="enscript-comment">/*
 * Local support routines
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">close_xattrfile</span>(vnode_t xvp, <span class="enscript-type">int</span> fileflags, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">open_xattrfile</span>(vnode_t vp, <span class="enscript-type">int</span> fileflags, vnode_t *xvpp, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">create_xattrfile</span>(vnode_t xvp, u_int32_t fileid, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">remove_xattrfile</span>(vnode_t xvp, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">get_xattrinfo</span>(vnode_t xvp, <span class="enscript-type">int</span> setting, attr_info_t *ainfop, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">rel_xattrinfo</span>(attr_info_t *ainfop);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">write_xattrinfo</span>(attr_info_t *ainfop);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">init_empty_resource_fork</span>(rsrcfork_header_t * rsrcforkhdr);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">lock_xattrfile</span>(vnode_t xvp, <span class="enscript-type">short</span> locktype, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">unlock_xattrfile</span>(vnode_t xvp, vfs_context_t context);


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> == <span class="enscript-variable-name">LITTLE_ENDIAN</span>
  <span class="enscript-type">static</span> <span class="enscript-type">void</span>  swap_adhdr(apple_double_header_t *adh);
  <span class="enscript-type">static</span> <span class="enscript-type">void</span>  swap_attrhdr(attr_header_t *ah, attr_info_t* info);

#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">swap_adhdr</span>(x)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">swap_attrhdr</span>(x, y)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">check_and_swap_attrhdr</span>(attr_header_t *ah, attr_info_t* ainfop);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">shift_data_down</span>(vnode_t xvp, off_t start, size_t len, off_t delta, vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">shift_data_up</span>(vnode_t xvp, off_t start, size_t len, off_t delta, vfs_context_t context);


<span class="enscript-comment">/*
 * Sanity check and swap the header of an AppleDouble file.  Assumes the buffer
 * is in big endian (as it would exist on disk).  Verifies the following:
 * - magic field
 * - version field
 * - number of entries
 * - that each entry fits within the file size
 *
 * If the header is invalid, ENOATTR is returned.
 *
 * NOTE: Does not attempt to validate the extended attributes header that
 * may be embedded in the Finder Info entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">check_and_swap_apple_double_header</span>(attr_info_t *ainfop)
{
	<span class="enscript-type">int</span> i, j;
	u_int32_t header_end;
	u_int32_t entry_end;
	size_t rawsize;
	apple_double_header_t *header;
	
	rawsize = ainfop-&gt;rawsize;
	header = (apple_double_header_t *) ainfop-&gt;rawdata;
	
	<span class="enscript-comment">/* Is the file big enough to contain an AppleDouble header? */</span>
	<span class="enscript-keyword">if</span> (rawsize &lt; offsetof(apple_double_header_t, entries))
		<span class="enscript-keyword">return</span> ENOATTR;
	
	<span class="enscript-comment">/* Swap the AppleDouble header fields to native order */</span>
	header-&gt;magic = SWAP32(header-&gt;magic);
	header-&gt;version = SWAP32(header-&gt;version);
	header-&gt;numEntries = SWAP16(header-&gt;numEntries);
	
	<span class="enscript-comment">/* Sanity check the AppleDouble header fields */</span>
	<span class="enscript-keyword">if</span> (header-&gt;magic != ADH_MAGIC ||
	    header-&gt;version != ADH_VERSION ||
	    header-&gt;numEntries &lt; 1 ||
	    header-&gt;numEntries &gt; 15) {
		<span class="enscript-keyword">return</span> ENOATTR;
	}
	
	<span class="enscript-comment">/* Calculate where the entries[] array ends */</span>
	header_end = offsetof(apple_double_header_t, entries) +
		header-&gt;numEntries * <span class="enscript-keyword">sizeof</span>(apple_double_entry_t);
	
	<span class="enscript-comment">/* Is the file big enough to contain the AppleDouble entries? */</span>
	<span class="enscript-keyword">if</span> (rawsize &lt; header_end) {
	    	<span class="enscript-keyword">return</span> ENOATTR;
	}
	
	<span class="enscript-comment">/* Swap and sanity check each AppleDouble entry */</span>
	<span class="enscript-keyword">for</span> (i=0; i&lt;header-&gt;numEntries; i++) {
		<span class="enscript-comment">/* Swap the per-entry fields to native order */</span>
		header-&gt;entries[i].type   = SWAP32(header-&gt;entries[i].type);
		header-&gt;entries[i].offset = SWAP32(header-&gt;entries[i].offset);
		header-&gt;entries[i].length = SWAP32(header-&gt;entries[i].length);
		
		entry_end = header-&gt;entries[i].offset + header-&gt;entries[i].length;
		
		<span class="enscript-comment">/*
		 * Does the entry's content start within the header itself,
		 * did the addition overflow, or does the entry's content
		 * extend past the end of the file?
		 */</span>
		<span class="enscript-keyword">if</span> (header-&gt;entries[i].offset &lt; header_end ||
		    entry_end &lt; header-&gt;entries[i].offset  ||
		    entry_end &gt; ainfop-&gt;filesize) {
			<span class="enscript-keyword">return</span> ENOATTR;
		}
		
		<span class="enscript-comment">/*
		 * Does the current entry's content overlap with a previous
		 * entry's content?
		 *
		 * Yes, this is O(N**2), and there are more efficient algorithms
		 * for testing pairwise overlap of N ranges when N is large.
		 * But we have already ensured N &lt; 16, and N is almost always 2.
		 * So there's no point in using a more complex algorithm.
		 */</span>
		
		<span class="enscript-keyword">for</span> (j=0; j&lt;i; j++) {
			<span class="enscript-keyword">if</span> (entry_end &gt; header-&gt;entries[j].offset &amp;&amp;
			    header-&gt;entries[j].offset + header-&gt;entries[j].length &gt; header-&gt;entries[i].offset) {
				<span class="enscript-keyword">return</span> ENOATTR;
			}
		}
	}
	
	<span class="enscript-keyword">return</span> 0;
}



<span class="enscript-comment">/*
 * Retrieve the data of an extended attribute.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_getxattr</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uio_t uio, size_t *size,
                 __unused <span class="enscript-type">int</span> options, vfs_context_t context)
{
	vnode_t xvp = NULL;
	attr_info_t ainfo;
	attr_header_t *header;
	attr_entry_t *entry;
	u_int8_t *attrdata;
	size_t datalen;
	<span class="enscript-type">int</span> namelen;
	<span class="enscript-type">int</span> isrsrcfork;
	<span class="enscript-type">int</span> fileflags;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> error;

	fileflags = FREAD;
	<span class="enscript-keyword">if</span> (bcmp(name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) == 0) {
		isrsrcfork = 1;
		<span class="enscript-comment">/*
		 * Open the file locked (shared) since the Carbon
		 * File Manager may have the Apple Double file open
		 * and could be changing the resource fork.
		 */</span>
		fileflags |= O_SHLOCK;
	} <span class="enscript-keyword">else</span> {
		isrsrcfork = 0;
	}

	<span class="enscript-keyword">if</span> ((error = open_xattrfile(vp, fileflags, &amp;xvp, context))) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ((error = get_xattrinfo(xvp, 0, &amp;ainfo, context))) {
		close_xattrfile(xvp, fileflags, context);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* Get the Finder Info. */</span>
	<span class="enscript-keyword">if</span> (bcmp(name, XATTR_FINDERINFO_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_FINDERINFO_NAME)) == 0) {
	
		<span class="enscript-keyword">if</span> (ainfo.finderinfo == NULL || ainfo.emptyfinderinfo) {
			error = ENOATTR;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio == NULL) {
			*size = FINDERINFOSIZE;
			error = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio_offset(uio) != 0) {
			error = EINVAL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio_resid(uio) &lt; FINDERINFOSIZE) {
			error = ERANGE;
		} <span class="enscript-keyword">else</span> {
			attrdata = (u_int8_t*)ainfo.filehdr + ainfo.finderinfo-&gt;offset;
			error = uiomove((caddr_t)attrdata, FINDERINFOSIZE, uio);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Read the Resource Fork. */</span>
	<span class="enscript-keyword">if</span> (isrsrcfork) {
		<span class="enscript-keyword">if</span> (!vnode_isreg(vp)) {
			error = EPERM;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ainfo.rsrcfork == NULL) {
			error = ENOATTR;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio == NULL) {
			*size = (size_t)ainfo.rsrcfork-&gt;length;
		} <span class="enscript-keyword">else</span> {
			uio_setoffset(uio, uio_offset(uio) + ainfo.rsrcfork-&gt;offset);
			error = VNOP_READ(xvp, uio, 0, context);
			<span class="enscript-keyword">if</span> (error == 0)
				uio_setoffset(uio, uio_offset(uio) - ainfo.rsrcfork-&gt;offset);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	<span class="enscript-keyword">if</span> (ainfo.attrhdr == NULL || ainfo.attr_entry == NULL) {
		error = ENOATTR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (uio_offset(uio) != 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	error = ENOATTR;
	namelen = strlen(name) + 1;
	header = ainfo.attrhdr;
	entry = ainfo.attr_entry;
	<span class="enscript-comment">/*
	 * Search for attribute name in the header.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; header-&gt;num_attrs &amp;&amp; ATTR_VALID(entry, ainfo); i++) {
		<span class="enscript-keyword">if</span> (strncmp((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)entry-&gt;name, name, namelen) == 0) {
			datalen = (size_t)entry-&gt;length;
			<span class="enscript-keyword">if</span> (uio == NULL) {
				*size = datalen;
				error = 0;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (uio_resid(uio) &lt; (user_ssize_t)datalen) {
				error = ERANGE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (entry-&gt;offset + datalen &lt; ATTR_MAX_HDR_SIZE) {
				attrdata = ((u_int8_t *)header + entry-&gt;offset);
				error = uiomove((caddr_t)attrdata, datalen, uio);
			} <span class="enscript-keyword">else</span> {
				uio_setoffset(uio, entry-&gt;offset);
				error = VNOP_READ(xvp, uio, 0, context);
				uio_setoffset(uio, 0);
			}
			<span class="enscript-keyword">break</span>;
		}
		entry = ATTR_NEXT(entry);
	}
<span class="enscript-reference">out</span>:	
	rel_xattrinfo(&amp;ainfo);
	close_xattrfile(xvp, fileflags, context);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Set the data of an extended attribute.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_setxattr</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uio_t uio, <span class="enscript-type">int</span> options, vfs_context_t context)
{
	vnode_t xvp = NULL;
	attr_info_t ainfo;
	attr_header_t *header;
	attr_entry_t *entry;
	attr_entry_t *lastentry;
	u_int8_t *attrdata;
	size_t datalen;
	size_t entrylen;
	size_t datafreespace;
	<span class="enscript-type">int</span> namelen;
	<span class="enscript-type">int</span> found = 0;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> splitdata;
	<span class="enscript-type">int</span> fileflags;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> finfo[FINDERINFOSIZE];
	
	datalen = uio_resid(uio);
	namelen = strlen(name) + 1;
	entrylen = ATTR_ENTRY_LENGTH(namelen);

	<span class="enscript-comment">/*
	 * By convention, Finder Info that is all zeroes is equivalent to not
	 * having a Finder Info EA.  So if we're trying to set the Finder Info
	 * to all zeroes, then delete it instead.  If a file didn't have an
	 * AppleDouble file before, this prevents creating an AppleDouble file
	 * with no useful content.
	 *
	 * If neither XATTR_CREATE nor XATTR_REPLACE were specified, we check
	 * for all zeroes Finder Info before opening the AppleDouble file.
	 * But if either of those options were specified, we need to open the
	 * AppleDouble file to see whether there was already Finder Info (so we
	 * can return an error if needed); this case is handled further below.
	 *
	 * NOTE: this copies the Finder Info data into the &quot;finfo&quot; local.
	 */</span>
	<span class="enscript-keyword">if</span> (bcmp(name, XATTR_FINDERINFO_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_FINDERINFO_NAME)) == 0) {
		<span class="enscript-comment">/*
		 * TODO: check the XATTR_CREATE and XATTR_REPLACE flags.
		 * That means we probably have to open_xattrfile and get_xattrinfo.
		 */</span>
		<span class="enscript-keyword">if</span> (uio_offset(uio) != 0 || datalen != FINDERINFOSIZE) {
			<span class="enscript-keyword">return</span> EINVAL;
		}
		error = uiomove(finfo, datalen, uio);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
		<span class="enscript-keyword">if</span> ((options &amp; (XATTR_CREATE|XATTR_REPLACE)) == 0 &amp;&amp;
		    bcmp(finfo, emptyfinfo, FINDERINFOSIZE) == 0) {
			error = default_removexattr(vp, name, 0, context);
			<span class="enscript-keyword">if</span> (error == ENOATTR)
				error = 0;
			<span class="enscript-keyword">return</span> error;
		}
	}
	
<span class="enscript-reference">start</span>:
	<span class="enscript-comment">/*
	 * Open the file locked since setting an attribute
	 * can change the layout of the Apple Double file.
	 */</span>
	fileflags = FREAD | FWRITE | O_EXLOCK;
	<span class="enscript-keyword">if</span> ((error = open_xattrfile(vp, O_CREAT | fileflags, &amp;xvp, context))) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ((error = get_xattrinfo(xvp, ATTR_SETTING, &amp;ainfo, context))) {
		close_xattrfile(xvp, fileflags, context);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* Set the Finder Info. */</span>
	<span class="enscript-keyword">if</span> (bcmp(name, XATTR_FINDERINFO_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_FINDERINFO_NAME)) == 0) {
		<span class="enscript-keyword">if</span> (ainfo.finderinfo &amp;&amp; !ainfo.emptyfinderinfo) {
			<span class="enscript-comment">/* attr exists and &quot;create&quot; was specified? */</span>
			<span class="enscript-keyword">if</span> (options &amp; XATTR_CREATE) {
				error = EEXIST;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* attr doesn't exists and &quot;replace&quot; was specified? */</span>
			<span class="enscript-keyword">if</span> (options &amp; XATTR_REPLACE) {
				error = ENOATTR;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		<span class="enscript-keyword">if</span> (options != 0 &amp;&amp; bcmp(finfo, emptyfinfo, FINDERINFOSIZE) == 0) {
			<span class="enscript-comment">/*
			 * Setting the Finder Info to all zeroes is equivalent to
			 * removing it.  Close the xattr file and let
			 * default_removexattr do the work (including deleting
			 * the xattr file if there are no other xattrs).
			 *
			 * Note that we have to handle the case where the
			 * Finder Info was already all zeroes, and we ignore
			 * ENOATTR.
			 *
			 * The common case where options == 0 was handled above.
			 */</span>
			rel_xattrinfo(&amp;ainfo);
			close_xattrfile(xvp, fileflags, context);
			error = default_removexattr(vp, name, 0, context);
			<span class="enscript-keyword">if</span> (error == ENOATTR)
				error = 0;
			<span class="enscript-keyword">return</span> error;
		}
		<span class="enscript-keyword">if</span> (ainfo.finderinfo) {
			attrdata = (u_int8_t *)ainfo.filehdr + ainfo.finderinfo-&gt;offset;
			bcopy(finfo, attrdata, datalen);
			ainfo.iosize = <span class="enscript-keyword">sizeof</span>(attr_header_t);
			error = write_xattrinfo(&amp;ainfo);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		error = ENOATTR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Write the Resource Fork. */</span>
	<span class="enscript-keyword">if</span> (bcmp(name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) == 0) {
		u_int32_t endoffset;

		<span class="enscript-keyword">if</span> (!vnode_isreg(vp)) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* Make sure we have a rsrc fork pointer.. */</span>
		<span class="enscript-keyword">if</span> (ainfo.rsrcfork == NULL) {
			error = ENOATTR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (ainfo.rsrcfork) {
			<span class="enscript-keyword">if</span> (ainfo.rsrcfork-&gt;length != 0) {
				<span class="enscript-keyword">if</span> (options &amp; XATTR_CREATE) {
					<span class="enscript-comment">/* attr exists, and create specified ? */</span>
					error = EEXIST;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}	
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Zero length AD rsrc fork */</span>
				<span class="enscript-keyword">if</span> (options &amp; XATTR_REPLACE) {
					<span class="enscript-comment">/* attr doesn't exist (0-length), but replace specified ? */</span>
					error = ENOATTR;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* We can't do much if we somehow didn't get an AD rsrc pointer */</span>
			error = ENOATTR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		endoffset = uio_resid(uio) + uio_offset(uio); <span class="enscript-comment">/* new size */</span>
		uio_setoffset(uio, uio_offset(uio) + ainfo.rsrcfork-&gt;offset);
		error = VNOP_WRITE(xvp, uio, 0, context);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		uio_setoffset(uio, uio_offset(uio) - ainfo.rsrcfork-&gt;offset);
		<span class="enscript-keyword">if</span> (endoffset &gt; ainfo.rsrcfork-&gt;length) {
			ainfo.rsrcfork-&gt;length = endoffset;
			ainfo.iosize = <span class="enscript-keyword">sizeof</span>(attr_header_t);
			error = write_xattrinfo(&amp;ainfo);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (datalen &gt; ATTR_MAX_SIZE) {
		<span class="enscript-keyword">return</span> (E2BIG);  <span class="enscript-comment">/* EINVAL instead ? */</span>
	}

	<span class="enscript-keyword">if</span> (ainfo.attrhdr == NULL) {
		error = ENOATTR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	header = ainfo.attrhdr;
	entry = ainfo.attr_entry;

	<span class="enscript-comment">/* Check if data area crosses the maximum header size. */</span>
	<span class="enscript-keyword">if</span> ((header-&gt;data_start + header-&gt;data_length + entrylen + datalen) &gt; ATTR_MAX_HDR_SIZE)
		splitdata = 1;  <span class="enscript-comment">/* do data I/O separately */</span>
	<span class="enscript-keyword">else</span>
		splitdata = 0;
	
	<span class="enscript-comment">/*
	 * See if attribute already exists.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; header-&gt;num_attrs &amp;&amp; ATTR_VALID(entry, ainfo); i++) {
		<span class="enscript-keyword">if</span> (strncmp((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)entry-&gt;name, name, namelen) == 0) {
			found = 1;
			<span class="enscript-keyword">break</span>;
		}
		entry = ATTR_NEXT(entry);
	}

	<span class="enscript-keyword">if</span> (found) {
		<span class="enscript-keyword">if</span> (options &amp; XATTR_CREATE) {
			error = EEXIST;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (datalen == entry-&gt;length) {
			<span class="enscript-keyword">if</span> (splitdata) {
				uio_setoffset(uio, entry-&gt;offset);
				error = VNOP_WRITE(xvp, uio, 0, context);
				uio_setoffset(uio, 0);
				<span class="enscript-keyword">if</span> (error) {
					printf(<span class="enscript-string">&quot;setxattr: VNOP_WRITE error %d\n&quot;</span>, error);
				}
			} <span class="enscript-keyword">else</span> {
				attrdata = (u_int8_t *)header + entry-&gt;offset;
				error = uiomove((caddr_t)attrdata, datalen, uio);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				ainfo.iosize = ainfo.attrhdr-&gt;data_start + ainfo.attrhdr-&gt;data_length;
				error = write_xattrinfo(&amp;ainfo);
				<span class="enscript-keyword">if</span> (error) {
					printf(<span class="enscript-string">&quot;setxattr: write_xattrinfo error %d\n&quot;</span>, error);
				}
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Brute force approach - just remove old entry and set new entry.
			 */</span>
			found = 0;
			rel_xattrinfo(&amp;ainfo);
			close_xattrfile(xvp, fileflags, context);
			error = default_removexattr(vp, name, options, context);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">return</span> (error);
			}
			<span class="enscript-comment">/* Clear XATTR_REPLACE option since we just removed the attribute. */</span>
			options &amp;= ~XATTR_REPLACE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">start</span>; <span class="enscript-comment">/* start over */</span>
		}

	}

	<span class="enscript-keyword">if</span> (options &amp; XATTR_REPLACE) {
		error = ENOATTR;  <span class="enscript-comment">/* nothing there to replace */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* Check if header size limit has been reached. */</span>
	<span class="enscript-keyword">if</span> ((header-&gt;data_start + entrylen) &gt; ATTR_MAX_HDR_SIZE) {
		error = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	datafreespace = header-&gt;total_size - (header-&gt;data_start + header-&gt;data_length);

	<span class="enscript-comment">/* Check if we need more space. */</span>
	<span class="enscript-keyword">if</span> ((datalen + entrylen) &gt; datafreespace) {
		size_t growsize;

		growsize = roundup((datalen + entrylen) - datafreespace, ATTR_BUF_SIZE);
		
		<span class="enscript-comment">/* Clip roundup size when we can still fit in ATTR_MAX_HDR_SIZE. */</span>
		<span class="enscript-keyword">if</span> (!splitdata &amp;&amp; (header-&gt;total_size + growsize) &gt; ATTR_MAX_HDR_SIZE) {
			growsize = ATTR_MAX_HDR_SIZE - header-&gt;total_size;
		}

		ainfo.filesize += growsize;
		error = vnode_setsize(xvp, ainfo.filesize, 0, context);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;setxattr: VNOP_TRUNCATE error %d\n&quot;</span>, error);
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		<span class="enscript-comment">/*
		 * Move the resource fork out of the way.
		 */</span>
		<span class="enscript-keyword">if</span> (ainfo.rsrcfork) {
			<span class="enscript-keyword">if</span> (ainfo.rsrcfork-&gt;length != 0) {
				shift_data_down(xvp,
						ainfo.rsrcfork-&gt;offset,
						ainfo.rsrcfork-&gt;length,
						growsize, context);
			}
			ainfo.rsrcfork-&gt;offset += growsize;
		}
		ainfo.finderinfo-&gt;length += growsize;
		header-&gt;total_size += growsize;
	}

	<span class="enscript-comment">/* Make space for a new entry. */</span>
	<span class="enscript-keyword">if</span> (splitdata) {
		shift_data_down(xvp,
				header-&gt;data_start,
				header-&gt;data_length,
				entrylen, context);
	} <span class="enscript-keyword">else</span> {
		bcopy((u_int8_t *)header + header-&gt;data_start,
		      (u_int8_t *)header + header-&gt;data_start + entrylen,
		      header-&gt;data_length);
	}
	header-&gt;data_start += entrylen;

	<span class="enscript-comment">/* Fix up entry data offsets. */</span>
	lastentry = entry;
	<span class="enscript-keyword">for</span> (entry = ainfo.attr_entry; entry != lastentry &amp;&amp; ATTR_VALID(entry, ainfo); entry = ATTR_NEXT(entry)) {
		entry-&gt;offset += entrylen;
	}
	
	<span class="enscript-comment">/*
	 * If the attribute data area is entirely within
	 * the header buffer, then just update the buffer,
	 * otherwise we'll write it separately to the file.
	 */</span>
	<span class="enscript-keyword">if</span> (splitdata) {
		off_t offset;

		<span class="enscript-comment">/* Write new attribute data after the end of existing data. */</span>
		offset = header-&gt;data_start + header-&gt;data_length;
		uio_setoffset(uio, offset);
		error = VNOP_WRITE(xvp, uio, 0, context);
		uio_setoffset(uio, 0);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;setxattr: VNOP_WRITE error %d\n&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	} <span class="enscript-keyword">else</span> {
		attrdata = (u_int8_t *)header + header-&gt;data_start + header-&gt;data_length;
		
		error = uiomove((caddr_t)attrdata, datalen, uio);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;setxattr: uiomove error %d\n&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/* Create the attribute entry. */</span>
	lastentry-&gt;length = datalen;
	lastentry-&gt;offset = header-&gt;data_start + header-&gt;data_length;
	lastentry-&gt;namelen = namelen;
	lastentry-&gt;flags = 0;
	bcopy(name, &amp;lastentry-&gt;name[0], namelen);

	<span class="enscript-comment">/* Update the attributes header. */</span>
	header-&gt;num_attrs++;
	header-&gt;data_length += datalen;

	<span class="enscript-keyword">if</span> (splitdata) {
		<span class="enscript-comment">/* Only write the entries, since the data was written separately. */</span>
		ainfo.iosize = ainfo.attrhdr-&gt;data_start;
	} <span class="enscript-keyword">else</span> {
		 <span class="enscript-comment">/* The entry and data are both in the header; write them together. */</span>
		ainfo.iosize = ainfo.attrhdr-&gt;data_start + ainfo.attrhdr-&gt;data_length;
	}
	error = write_xattrinfo(&amp;ainfo);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;setxattr: write_xattrinfo error %d\n&quot;</span>, error);
	}

<span class="enscript-reference">out</span>:	
	rel_xattrinfo(&amp;ainfo);
	close_xattrfile(xvp, fileflags, context);

	<span class="enscript-comment">/* Touch the change time if we changed an attribute. */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-type">struct</span> vnode_attr va;

		<span class="enscript-comment">/* Re-write the mtime to cause a ctime change. */</span>
		VATTR_INIT(&amp;va);
		VATTR_WANTED(&amp;va, va_modify_time);
		<span class="enscript-keyword">if</span> (vnode_getattr(vp, &amp;va, context) == 0) {
			VATTR_INIT(&amp;va);
			VATTR_SET(&amp;va, va_modify_time, va.va_modify_time);
			(<span class="enscript-type">void</span>) vnode_setattr(vp, &amp;va, context);
		}
	}
	
	post_event_if_success(vp, error, NOTE_ATTRIB);

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Remove an extended attribute.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_removexattr</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, __unused <span class="enscript-type">int</span> options, vfs_context_t context)
{
	vnode_t xvp = NULL;
	attr_info_t ainfo;
	attr_header_t *header;
	attr_entry_t *entry;
	attr_entry_t *oldslot;
	u_int8_t *attrdata;
	u_int32_t dataoff;
	size_t datalen;
	size_t entrylen;
	<span class="enscript-type">int</span> namelen;
	<span class="enscript-type">int</span> found = 0, lastone = 0;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> splitdata;
	<span class="enscript-type">int</span> attrcount = 0;
	<span class="enscript-type">int</span> isrsrcfork;
	<span class="enscript-type">int</span> fileflags;
	<span class="enscript-type">int</span> error;

	fileflags = FREAD | FWRITE;
	<span class="enscript-keyword">if</span> (bcmp(name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) == 0) {
		isrsrcfork = 1;
		<span class="enscript-comment">/*
		 * Open the file locked (exclusive) since the Carbon
		 * File Manager may have the Apple Double file open
		 * and could be changing the resource fork.
		 */</span>
		fileflags |= O_EXLOCK;
	} <span class="enscript-keyword">else</span> {
		isrsrcfork = 0;
	}

	<span class="enscript-keyword">if</span> ((error = open_xattrfile(vp, fileflags, &amp;xvp, context))) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ((error = get_xattrinfo(xvp, 0, &amp;ainfo, context))) {
		close_xattrfile(xvp, fileflags, context);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (ainfo.attrhdr)
		attrcount += ainfo.attrhdr-&gt;num_attrs;
	<span class="enscript-keyword">if</span> (ainfo.rsrcfork)
		++attrcount;
	<span class="enscript-keyword">if</span> (ainfo.finderinfo &amp;&amp; !ainfo.emptyfinderinfo)
		++attrcount;

	<span class="enscript-comment">/* Clear the Finder Info. */</span>
	<span class="enscript-keyword">if</span> (bcmp(name, XATTR_FINDERINFO_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_FINDERINFO_NAME)) == 0) {
		<span class="enscript-keyword">if</span> (ainfo.finderinfo == NULL || ainfo.emptyfinderinfo) {
			error = ENOATTR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* On removal of last attribute the ._ file is removed. */</span>
		<span class="enscript-keyword">if</span> (--attrcount == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		attrdata = (u_int8_t *)ainfo.filehdr + ainfo.finderinfo-&gt;offset;
		bzero((caddr_t)attrdata, FINDERINFOSIZE);
		ainfo.iosize = <span class="enscript-keyword">sizeof</span>(attr_header_t);
		error = write_xattrinfo(&amp;ainfo);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Clear the Resource Fork. */</span>
	<span class="enscript-keyword">if</span> (isrsrcfork) {
		<span class="enscript-keyword">if</span> (!vnode_isreg(vp)) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (ainfo.rsrcfork == NULL || ainfo.rsrcfork-&gt;length == 0) {
			error = ENOATTR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* On removal of last attribute the ._ file is removed. */</span>
		<span class="enscript-keyword">if</span> (--attrcount == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-comment">/*
		 * XXX
		 * If the resource fork isn't the last AppleDouble
		 * entry then the space needs to be reclaimed by
		 * shifting the entries after the resource fork.
		 */</span>
		<span class="enscript-keyword">if</span> ((ainfo.rsrcfork-&gt;offset + ainfo.rsrcfork-&gt;length) == ainfo.filesize) {
			ainfo.filesize -= ainfo.rsrcfork-&gt;length;
			error = vnode_setsize(xvp, ainfo.filesize, 0, context);
		}
		<span class="enscript-keyword">if</span> (error == 0) {
			ainfo.rsrcfork-&gt;length = 0;
			ainfo.iosize = <span class="enscript-keyword">sizeof</span>(attr_header_t);
			error = write_xattrinfo(&amp;ainfo);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (ainfo.attrhdr == NULL) {
		error = ENOATTR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	namelen = strlen(name) + 1;
	header = ainfo.attrhdr;
	entry = ainfo.attr_entry;

	<span class="enscript-comment">/*
	 * See if this attribute exists.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; header-&gt;num_attrs &amp;&amp; ATTR_VALID(entry, ainfo); i++) {
		<span class="enscript-keyword">if</span> (strncmp((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)entry-&gt;name, name, namelen) == 0) {
			found = 1;
			<span class="enscript-keyword">if</span> ((i+1) == header-&gt;num_attrs)
				lastone = 1;
			<span class="enscript-keyword">break</span>;
		}
		entry = ATTR_NEXT(entry);
	}
	<span class="enscript-keyword">if</span> (!found) {
		error = ENOATTR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* On removal of last attribute the ._ file is removed. */</span>
	<span class="enscript-keyword">if</span> (--attrcount == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	datalen = entry-&gt;length;
	dataoff = entry-&gt;offset;
	entrylen = ATTR_ENTRY_LENGTH(namelen);
	<span class="enscript-keyword">if</span> ((header-&gt;data_start + header-&gt;data_length) &gt; ATTR_MAX_HDR_SIZE)
		splitdata = 1;
	<span class="enscript-keyword">else</span>
		splitdata = 0;

	<span class="enscript-comment">/* Remove the attribute entry. */</span>
	<span class="enscript-keyword">if</span> (!lastone) {
		bcopy((u_int8_t *)entry + entrylen, (u_int8_t *)entry,
		      ((size_t)header + header-&gt;data_start) - ((size_t)entry + entrylen));
	}

	<span class="enscript-comment">/* Adjust the attribute data. */</span>
	<span class="enscript-keyword">if</span> (splitdata) {
		shift_data_up(xvp,
		              header-&gt;data_start,
		              dataoff - header-&gt;data_start,
		              entrylen,
		              context);
		<span class="enscript-keyword">if</span> (!lastone) {
			shift_data_up(xvp,
			              dataoff + datalen,
			              (header-&gt;data_start + header-&gt;data_length) - (dataoff + datalen),
			              datalen + entrylen,
			              context);
		}
		<span class="enscript-comment">/* XXX write zeros to freed space ? */</span>
		ainfo.iosize = ainfo.attrhdr-&gt;data_start - entrylen;
	} <span class="enscript-keyword">else</span> {


		bcopy((u_int8_t *)header + header-&gt;data_start,
		      (u_int8_t *)header + header-&gt;data_start - entrylen,
		      dataoff - header-&gt;data_start);
		<span class="enscript-keyword">if</span> (!lastone) {
			bcopy((u_int8_t *)header + dataoff + datalen,
			      (u_int8_t *)header + dataoff - entrylen,
			      (header-&gt;data_start + header-&gt;data_length) - (dataoff + datalen));
		}
		bzero (((u_int8_t *)header + header-&gt;data_start + header-&gt;data_length) - (datalen + entrylen), (datalen + entrylen));
		ainfo.iosize = ainfo.attrhdr-&gt;data_start + ainfo.attrhdr-&gt;data_length;
	}

	<span class="enscript-comment">/* Adjust the header values and entry offsets. */</span>
	header-&gt;num_attrs--;
	header-&gt;data_start -= entrylen;
	header-&gt;data_length -= datalen;

	oldslot = entry;
	entry = ainfo.attr_entry;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; header-&gt;num_attrs &amp;&amp; ATTR_VALID(entry, ainfo); i++) {
		entry-&gt;offset -= entrylen;
		<span class="enscript-keyword">if</span> (entry &gt;= oldslot)
			entry-&gt;offset -= datalen;
		entry = ATTR_NEXT(entry);
	}
	error = write_xattrinfo(&amp;ainfo);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;removexattr: write_xattrinfo error %d\n&quot;</span>, error);
	}
<span class="enscript-reference">out</span>:
	rel_xattrinfo(&amp;ainfo);

	<span class="enscript-comment">/* When there are no more attributes remove the ._ file. */</span>
	<span class="enscript-keyword">if</span> (attrcount == 0) {
		<span class="enscript-keyword">if</span> (fileflags &amp; O_EXLOCK)
			(<span class="enscript-type">void</span>) unlock_xattrfile(xvp, context);
		VNOP_CLOSE(xvp, fileflags, context);
		vnode_rele(xvp);
		error = remove_xattrfile(xvp, context);
		vnode_put(xvp);
	} <span class="enscript-keyword">else</span> {
		close_xattrfile(xvp, fileflags, context);
	}
	<span class="enscript-comment">/* Touch the change time if we changed an attribute. */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-type">struct</span> vnode_attr va;

		<span class="enscript-comment">/* Re-write the mtime to cause a ctime change. */</span>
		VATTR_INIT(&amp;va);
		VATTR_WANTED(&amp;va, va_modify_time);
		<span class="enscript-keyword">if</span> (vnode_getattr(vp, &amp;va, context) == 0) {
			VATTR_INIT(&amp;va);
			VATTR_SET(&amp;va, va_modify_time, va.va_modify_time);
			(<span class="enscript-type">void</span>) vnode_setattr(vp, &amp;va, context);
		}
	}

	post_event_if_success(vp, error, NOTE_ATTRIB);

	<span class="enscript-keyword">return</span> (error);
	
}


<span class="enscript-comment">/*
 * Retrieve the list of extended attribute names.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_listxattr</span>(vnode_t vp, uio_t uio, size_t *size, __unused <span class="enscript-type">int</span> options, vfs_context_t context)
{
	vnode_t xvp = NULL;
	attr_info_t ainfo;
	attr_entry_t *entry;
	<span class="enscript-type">int</span> i, count;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * We do not zero &quot;*size&quot; here as we don't want to stomp a size set when
	 * VNOP_LISTXATTR processed any native EAs.  That size is initially zeroed by the
	 * system call layer, up in listxattr or flistxattr.
	 */</span>

	<span class="enscript-keyword">if</span> ((error = open_xattrfile(vp, FREAD, &amp;xvp, context))) {
		<span class="enscript-keyword">if</span> (error == ENOATTR)
			error = 0;
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ((error = get_xattrinfo(xvp, 0, &amp;ainfo, context))) {
		<span class="enscript-keyword">if</span> (error == ENOATTR)
			error = 0;
		close_xattrfile(xvp, FREAD, context);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* Check for Finder Info. */</span>
	<span class="enscript-keyword">if</span> (ainfo.finderinfo &amp;&amp; !ainfo.emptyfinderinfo) {
		<span class="enscript-keyword">if</span> (uio == NULL) {
			*size += <span class="enscript-keyword">sizeof</span>(XATTR_FINDERINFO_NAME);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio_resid(uio) &lt; (user_ssize_t)<span class="enscript-keyword">sizeof</span>(XATTR_FINDERINFO_NAME)) {
			error = ERANGE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> {
			error = uiomove(XATTR_FINDERINFO_NAME,
			                <span class="enscript-keyword">sizeof</span>(XATTR_FINDERINFO_NAME), uio);
			<span class="enscript-keyword">if</span> (error) {
				error = ERANGE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	<span class="enscript-comment">/* Check for Resource Fork. */</span>
	<span class="enscript-keyword">if</span> (vnode_isreg(vp) &amp;&amp; ainfo.rsrcfork) {
		<span class="enscript-keyword">if</span> (uio == NULL) {
			*size += <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio_resid(uio) &lt; (user_ssize_t)<span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) {
			error = ERANGE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> {
			error = uiomove(XATTR_RESOURCEFORK_NAME,
			                <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME), uio);
			<span class="enscript-keyword">if</span> (error) {
				error = ERANGE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	<span class="enscript-comment">/* Check for attributes. */</span>
	<span class="enscript-keyword">if</span> (ainfo.attrhdr) {
		count = ainfo.attrhdr-&gt;num_attrs;
		<span class="enscript-keyword">for</span> (i = 0, entry = ainfo.attr_entry; i &lt; count &amp;&amp; ATTR_VALID(entry, ainfo); i++) {
			<span class="enscript-keyword">if</span> (xattr_protected((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)entry-&gt;name) ||
			    xattr_validatename((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)entry-&gt;name) != 0) {
				entry = ATTR_NEXT(entry);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (uio == NULL) {
				*size += entry-&gt;namelen;
				entry = ATTR_NEXT(entry);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (uio_resid(uio) &lt; entry-&gt;namelen) {
				error = ERANGE;
				<span class="enscript-keyword">break</span>;
			}
			error = uiomove((caddr_t) entry-&gt;name, entry-&gt;namelen, uio);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">if</span> (error != EFAULT)
					error = ERANGE;
				<span class="enscript-keyword">break</span>;
			}		
			entry = ATTR_NEXT(entry);
		}
	}
<span class="enscript-reference">out</span>:	
	rel_xattrinfo(&amp;ainfo);
	close_xattrfile(xvp, FREAD, context);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">open_xattrfile</span>(vnode_t vp, <span class="enscript-type">int</span> fileflags, vnode_t *xvpp, vfs_context_t context)
{
	vnode_t xvp = NULLVP;
	vnode_t dvp = NULLVP;
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">char</span> smallname[64];
	<span class="enscript-type">char</span> *filename = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *basename = NULL;
	size_t len;
	errno_t error;
	<span class="enscript-type">int</span> opened = 0;
	<span class="enscript-type">int</span> referenced = 0;

	<span class="enscript-keyword">if</span> (vnode_isvroot(vp) &amp;&amp; vnode_isdir(vp)) {
		<span class="enscript-comment">/*
		 * For the root directory use &quot;._.&quot; to hold the attributes.
		 */</span>
		filename = &amp;smallname[0];
		snprintf(filename, <span class="enscript-keyword">sizeof</span>(smallname), <span class="enscript-string">&quot;%s%s&quot;</span>, ATTR_FILE_PREFIX, <span class="enscript-string">&quot;.&quot;</span>);
		dvp = vp;  <span class="enscript-comment">/* the &quot;._.&quot; file resides in the root dir */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">lookup</span>;
	}
	<span class="enscript-keyword">if</span> ( (dvp = vnode_getparent(vp)) == NULLVP) {
		error = ENOATTR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> ( (basename = vnode_getname(vp)) == NULL) {
		error = ENOATTR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* &quot;._&quot; Attribute files cannot have attributes */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VREG &amp;&amp; strlen(basename) &gt; 2 &amp;&amp;
	    basename[0] == <span class="enscript-string">'.'</span> &amp;&amp; basename[1] == <span class="enscript-string">'_'</span>) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	filename = &amp;smallname[0];
	len = snprintf(filename, <span class="enscript-keyword">sizeof</span>(smallname), <span class="enscript-string">&quot;%s%s&quot;</span>, ATTR_FILE_PREFIX, basename);
	<span class="enscript-keyword">if</span> (len &gt;= <span class="enscript-keyword">sizeof</span>(smallname)) {
		len++;  <span class="enscript-comment">/* snprintf result doesn't include '\0' */</span>
		MALLOC(filename, <span class="enscript-type">char</span> *, len, M_TEMP, M_WAITOK);
		len = snprintf(filename, len, <span class="enscript-string">&quot;%s%s&quot;</span>, ATTR_FILE_PREFIX, basename);
	}
	<span class="enscript-comment">/*
	 * Note that the lookup here does not authorize.  Since we are looking
	 * up in the same directory that we already have the file vnode in,
	 * we must have been given the file vnode legitimately.  Read/write
	 * access has already been authorized in layers above for calls from
	 * userspace, and the authorization code using this path to read
	 * file security from the EA must always get access
	 */</span>
<span class="enscript-reference">lookup</span>:
	NDINIT(&amp;nd, LOOKUP, OP_OPEN, LOCKLEAF | NOFOLLOW | USEDVP | DONOTAUTH,
	       UIO_SYSSPACE, CAST_USER_ADDR_T(filename), context);
   	nd.ni_dvp = dvp;

	<span class="enscript-keyword">if</span> (fileflags &amp; O_CREAT) {
		nd.ni_cnd.cn_nameiop = CREATE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
		nd.ni_op = OP_LINK;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (dvp != vp) {
			nd.ni_cnd.cn_flags |= LOCKPARENT;
		}
		<span class="enscript-keyword">if</span> ( (error = namei(&amp;nd))) {
		        nd.ni_dvp = NULLVP;
			error = ENOATTR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> ( (xvp = nd.ni_vp) == NULLVP) {
			uid_t uid;
			gid_t gid;
			mode_t umode;
	
			<span class="enscript-comment">/*
			 * Pick up uid/gid/mode from target file.
			 */</span>
			VATTR_INIT(&amp;va);
			VATTR_WANTED(&amp;va, va_uid);
			VATTR_WANTED(&amp;va, va_gid);
			VATTR_WANTED(&amp;va, va_mode);
			<span class="enscript-keyword">if</span> (VNOP_GETATTR(vp, &amp;va, context) == 0  &amp;&amp;
			    VATTR_IS_SUPPORTED(&amp;va, va_uid)  &amp;&amp;
			    VATTR_IS_SUPPORTED(&amp;va, va_gid)  &amp;&amp;
			    VATTR_IS_SUPPORTED(&amp;va, va_mode)) {
				uid = va.va_uid;
				gid = va.va_gid;
				umode = va.va_mode &amp; (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
			} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* fallback values */</span> {
				uid = KAUTH_UID_NONE;
				gid = KAUTH_GID_NONE;
				umode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
			}

			VATTR_INIT(&amp;va);
			VATTR_SET(&amp;va, va_type, VREG);
			VATTR_SET(&amp;va, va_mode, umode);
			<span class="enscript-keyword">if</span> (uid != KAUTH_UID_NONE)
				VATTR_SET(&amp;va, va_uid, uid);
			<span class="enscript-keyword">if</span> (gid != KAUTH_GID_NONE)
				VATTR_SET(&amp;va, va_gid, gid);

			error = vn_create(dvp, &amp;nd.ni_vp, &amp;nd, &amp;va,
			                  VN_CREATE_NOAUTH | VN_CREATE_NOINHERIT | VN_CREATE_NOLABEL,
					  0, NULL,
			                  context);
			<span class="enscript-keyword">if</span> (error)
				error = ENOATTR;
			<span class="enscript-keyword">else</span>
				xvp = nd.ni_vp;
		}
		nameidone(&amp;nd);
		<span class="enscript-keyword">if</span> (dvp != vp) {
			vnode_put(dvp);  <span class="enscript-comment">/* drop iocount from LOCKPARENT request above */</span>
		}
		<span class="enscript-keyword">if</span> (error)
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((error = namei(&amp;nd))) {
			nd.ni_dvp = NULLVP;
			error = ENOATTR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	        xvp = nd.ni_vp;
		nameidone(&amp;nd);
	}
	nd.ni_dvp = NULLVP;

	<span class="enscript-keyword">if</span> (xvp-&gt;v_type != VREG) {
		error = ENOATTR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * Owners must match.
	 */</span>
	VATTR_INIT(&amp;va);
	VATTR_WANTED(&amp;va, va_uid);
	<span class="enscript-keyword">if</span> (VNOP_GETATTR(vp, &amp;va, context) == 0 &amp;&amp; VATTR_IS_SUPPORTED(&amp;va, va_uid)) {
		uid_t owner = va.va_uid;

		VATTR_INIT(&amp;va);
		VATTR_WANTED(&amp;va, va_uid);
		<span class="enscript-keyword">if</span> (VNOP_GETATTR(xvp, &amp;va, context) == 0 &amp;&amp; (owner != va.va_uid)) {
			error = ENOATTR;  <span class="enscript-comment">/* don't use this &quot;._&quot; file */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	
	<span class="enscript-keyword">if</span> ( (error = VNOP_OPEN(xvp, fileflags &amp; ~(O_EXLOCK | O_SHLOCK), context))) {
		error = ENOATTR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	opened = 1;

	<span class="enscript-keyword">if</span> ((error = vnode_ref(xvp))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	referenced = 1;

	<span class="enscript-comment">/* If create was requested, make sure file header exists. */</span>
	<span class="enscript-keyword">if</span> (fileflags &amp; O_CREAT) {
		VATTR_INIT(&amp;va);
		VATTR_WANTED(&amp;va, va_data_size);
		VATTR_WANTED(&amp;va, va_fileid);
		VATTR_WANTED(&amp;va, va_nlink);
		<span class="enscript-keyword">if</span> ( (error = vnode_getattr(xvp, &amp;va, context)) != 0) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	
		<span class="enscript-comment">/* If the file is empty then add a default header. */</span>
		<span class="enscript-keyword">if</span> (va.va_data_size == 0) {
			<span class="enscript-comment">/* Don't adopt hard-linked &quot;._&quot; files. */</span>
			<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;va, va_nlink) &amp;&amp; va.va_nlink &gt; 1) {
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> ( (error = create_xattrfile(xvp, (u_int32_t)va.va_fileid, context)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	<span class="enscript-comment">/* Apply file locking if requested. */</span>	
	<span class="enscript-keyword">if</span> (fileflags &amp; (O_EXLOCK | O_SHLOCK)) {
		<span class="enscript-type">short</span> locktype;

		locktype = (fileflags &amp; O_EXLOCK) ? F_WRLCK : F_RDLCK;
		error = lock_xattrfile(xvp, locktype, context);
		<span class="enscript-keyword">if</span> (error)
			error = ENOATTR;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (xvp != NULLVP) {
			<span class="enscript-keyword">if</span> (opened) {
				(<span class="enscript-type">void</span>) VNOP_CLOSE(xvp, fileflags, context);
			}

			<span class="enscript-keyword">if</span> (fileflags &amp; O_CREAT) {
				<span class="enscript-comment">/* Delete the xattr file if we encountered any errors */</span>
				(<span class="enscript-type">void</span>) remove_xattrfile (xvp, context);	
			}

			<span class="enscript-keyword">if</span> (referenced) {
				(<span class="enscript-type">void</span>) vnode_rele(xvp);
			}
			(<span class="enscript-type">void</span>) vnode_put(xvp);
			xvp = NULLVP;
		}
		<span class="enscript-keyword">if</span> ((error == ENOATTR) &amp;&amp; (fileflags &amp; O_CREAT)) {
			error = EPERM;
		}
	}
	<span class="enscript-comment">/* Release resources after error-handling */</span>
	<span class="enscript-keyword">if</span> (dvp &amp;&amp; (dvp != vp)) {
		vnode_put(dvp);
	}
	<span class="enscript-keyword">if</span> (basename) {
		vnode_putname(basename);
	}
	<span class="enscript-keyword">if</span> (filename &amp;&amp; filename != &amp;smallname[0]) {
		FREE(filename, M_TEMP);
	}

	*xvpp = xvp;  <span class="enscript-comment">/* return a referenced vnode */</span>
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">close_xattrfile</span>(vnode_t xvp, <span class="enscript-type">int</span> fileflags, vfs_context_t context)
{
<span class="enscript-comment">//	if (fileflags &amp; FWRITE)
</span><span class="enscript-comment">//		(void) VNOP_FSYNC(xvp, MNT_WAIT, context);
</span>
	<span class="enscript-keyword">if</span> (fileflags &amp; (O_EXLOCK | O_SHLOCK))
		(<span class="enscript-type">void</span>) unlock_xattrfile(xvp, context);

	(<span class="enscript-type">void</span>) VNOP_CLOSE(xvp, fileflags, context);
	(<span class="enscript-type">void</span>) vnode_rele(xvp);
	(<span class="enscript-type">void</span>) vnode_put(xvp);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">remove_xattrfile</span>(vnode_t xvp, vfs_context_t context)
{
	vnode_t dvp;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">char</span> *path = NULL;
	<span class="enscript-type">int</span> pathlen;
	<span class="enscript-type">int</span> error = 0;

	MALLOC_ZONE(path, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
	<span class="enscript-keyword">if</span> (path == NULL)
		<span class="enscript-keyword">return</span> ENOMEM;

	pathlen = MAXPATHLEN;
	error = vn_getpath(xvp, path, &amp;pathlen);
	<span class="enscript-keyword">if</span> (error) {
		FREE_ZONE(path, MAXPATHLEN, M_NAMEI);
		<span class="enscript-keyword">return</span> (error);
	}

	NDINIT(&amp;nd, DELETE, OP_UNLINK, LOCKPARENT | NOFOLLOW | DONOTAUTH,
	       UIO_SYSSPACE, CAST_USER_ADDR_T(path), context);
	error = namei(&amp;nd);
	FREE_ZONE(path, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> (error);
	}
	dvp = nd.ni_dvp;
	xvp = nd.ni_vp;

	error = VNOP_REMOVE(dvp, xvp, &amp;nd.ni_cnd, 0, context);
	nameidone(&amp;nd);
	vnode_put(dvp);
	vnode_put(xvp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Read in and parse the AppleDouble header and entries, and the extended
 * attribute header and entries if any.  Populates the fields of ainfop
 * based on the headers and entries found.
 *
 * The basic idea is to:
 * - Read in up to ATTR_MAX_HDR_SIZE bytes of the start of the file.  All
 *   AppleDouble entries, the extended attribute header, and extended
 *   attribute entries must lie within this part of the file; the rest of
 *   the AppleDouble handling code assumes this.  Plus it allows us to
 *   somewhat optimize by doing a smaller number of larger I/Os.
 * - Swap and sanity check the AppleDouble header (including the AppleDouble
 *   entries).
 * - Find the Finder Info and Resource Fork entries, if any.
 * - If we're going to be writing, try to make sure the Finder Info entry has
 *   room to store the extended attribute header, plus some space for extended
 *   attributes.
 * - Swap and sanity check the extended attribute header and entries (if any).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">get_xattrinfo</span>(vnode_t xvp, <span class="enscript-type">int</span> setting, attr_info_t *ainfop, vfs_context_t context)
{
	uio_t auio = NULL;
	<span class="enscript-type">void</span> * buffer = NULL;
	apple_double_header_t  *filehdr;
	<span class="enscript-type">struct</span> vnode_attr va;
	size_t iosize;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> error;

	bzero(ainfop, <span class="enscript-keyword">sizeof</span>(attr_info_t));
	ainfop-&gt;filevp = xvp;
	ainfop-&gt;context = context;
	VATTR_INIT(&amp;va);
	VATTR_WANTED(&amp;va, va_data_size);
	VATTR_WANTED(&amp;va, va_fileid);
	<span class="enscript-keyword">if</span> ((error = vnode_getattr(xvp, &amp;va, context))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bail</span>;
	}
	ainfop-&gt;filesize = va.va_data_size;

	<span class="enscript-comment">/* When setting attributes, allow room for the header to grow. */</span>
	<span class="enscript-keyword">if</span> (setting)
		iosize = ATTR_MAX_HDR_SIZE;
	<span class="enscript-keyword">else</span>
		iosize = MIN(ATTR_MAX_HDR_SIZE, ainfop-&gt;filesize);

	<span class="enscript-keyword">if</span> (iosize == 0) {
		error = ENOATTR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bail</span>;
	}
	ainfop-&gt;iosize = iosize;
	MALLOC(buffer, <span class="enscript-type">void</span> *, iosize, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (buffer == NULL){
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bail</span>;
	}

	auio = uio_create(1, 0, UIO_SYSSPACE, UIO_READ);
	uio_addiov(auio, (uintptr_t)buffer, iosize);

	<span class="enscript-comment">/* Read the file header. */</span>
	error = VNOP_READ(xvp, auio, 0, context);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bail</span>;
	}
	ainfop-&gt;rawsize = iosize - uio_resid(auio);
	ainfop-&gt;rawdata = (u_int8_t *)buffer;
	
	filehdr = (apple_double_header_t *)buffer;

	error = check_and_swap_apple_double_header(ainfop);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bail</span>;
	
	ainfop-&gt;filehdr = filehdr;  <span class="enscript-comment">/* valid AppleDouble header */</span>

	<span class="enscript-comment">/* rel_xattrinfo is responsible for freeing the header buffer */</span>
	buffer = NULL;

	<span class="enscript-comment">/* Find the Finder Info and Resource Fork entries, if any */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; filehdr-&gt;numEntries; ++i) {
		<span class="enscript-keyword">if</span> (filehdr-&gt;entries[i].type == AD_FINDERINFO &amp;&amp;
		    filehdr-&gt;entries[i].length &gt;= FINDERINFOSIZE) {
			<span class="enscript-comment">/* We found the Finder Info entry. */</span>
			ainfop-&gt;finderinfo = &amp;filehdr-&gt;entries[i];
			
			<span class="enscript-comment">/*
			 * Is the Finder Info &quot;empty&quot; (all zeroes)?  If so,
			 * we'll pretend like the Finder Info extended attribute
			 * does not exist.
			 *
			 * Note: we have to make sure the Finder Info is
			 * contained within the buffer we have already read,
			 * to avoid accidentally accessing a bogus address.
			 * If it is outside the buffer, we just assume the
			 * Finder Info is non-empty.
			 */</span>
			<span class="enscript-keyword">if</span> (ainfop-&gt;finderinfo-&gt;offset + FINDERINFOSIZE &lt;= ainfop-&gt;rawsize &amp;&amp;
			    bcmp((u_int8_t*)ainfop-&gt;filehdr + ainfop-&gt;finderinfo-&gt;offset, emptyfinfo, <span class="enscript-keyword">sizeof</span>(emptyfinfo)) == 0) {
				ainfop-&gt;emptyfinderinfo = 1;
			}
		}
		<span class="enscript-keyword">if</span> (filehdr-&gt;entries[i].type == AD_RESOURCE) {
			<span class="enscript-comment">/*
			 * Ignore zero-length resource forks when getting.  If setting,
			 * we need to remember the resource fork entry so it can be
			 * updated once the new content has been written.
			 */</span>
			<span class="enscript-keyword">if</span> (filehdr-&gt;entries[i].length == 0 &amp;&amp; !setting)
				<span class="enscript-keyword">continue</span>;
			
			<span class="enscript-comment">/*
			 * Check to see if any &quot;empty&quot; resource fork is ours (i.e. is ignorable).
			 *
			 * The &quot;empty&quot; resource headers we created have a system data tag of:
			 * &quot;This resource fork intentionally left blank   &quot;
			 */</span>
			<span class="enscript-keyword">if</span> (filehdr-&gt;entries[i].length == <span class="enscript-keyword">sizeof</span>(rsrcfork_header_t) &amp;&amp; !setting) {
				uio_t  rf_uio;
				u_int8_t  systemData[64];
				<span class="enscript-type">int</span>  rf_err;


				<span class="enscript-comment">/* Read the system data which starts at byte 16 */</span>
				rf_uio = uio_create(1, 0, UIO_SYSSPACE, UIO_READ);
				uio_addiov(rf_uio, (uintptr_t)systemData, <span class="enscript-keyword">sizeof</span>(systemData));
				uio_setoffset(rf_uio, filehdr-&gt;entries[i].offset + 16);
				rf_err = VNOP_READ(xvp, rf_uio, 0, context);
				uio_free(rf_uio);

				<span class="enscript-keyword">if</span> (rf_err != 0 ||
				    bcmp(systemData, RF_EMPTY_TAG, <span class="enscript-keyword">sizeof</span>(RF_EMPTY_TAG)) == 0) {
					<span class="enscript-keyword">continue</span>;  <span class="enscript-comment">/* skip this resource fork */</span>
				}
			}
			ainfop-&gt;rsrcfork = &amp;filehdr-&gt;entries[i];
			<span class="enscript-keyword">if</span> (i != (filehdr-&gt;numEntries - 1)) {
				printf(<span class="enscript-string">&quot;get_xattrinfo: resource fork not last entry\n&quot;</span>);
				ainfop-&gt;readonly = 1;
			}
			<span class="enscript-keyword">continue</span>;
		}
	}
	
	<span class="enscript-comment">/*
	 * See if this file looks like it is laid out correctly to contain
	 * extended attributes.  If so, then do the following:
	 *
	 * - If we're going to be writing, try to make sure the Finder Info
	 *   entry has room to store the extended attribute header, plus some
	 *   space for extended attributes.
	 *
	 * - Swap and sanity check the extended attribute header and entries
	 *   (if any).
	 */</span>
	<span class="enscript-keyword">if</span> (filehdr-&gt;numEntries == 2 &amp;&amp;
	    ainfop-&gt;finderinfo == &amp;filehdr-&gt;entries[0] &amp;&amp;
	    ainfop-&gt;rsrcfork == &amp;filehdr-&gt;entries[1] &amp;&amp;
	    ainfop-&gt;finderinfo-&gt;offset == offsetof(apple_double_header_t, finfo)) {
		attr_header_t *attrhdr;
		attrhdr = (attr_header_t *)filehdr;
		<span class="enscript-comment">/*
		 * If we're going to be writing, try to make sure the Finder
		 * Info entry has room to store the extended attribute header,
		 * plus some space for extended attributes.
		 */</span>
		<span class="enscript-keyword">if</span> (setting &amp;&amp; ainfop-&gt;finderinfo-&gt;length == FINDERINFOSIZE) {
			size_t delta;
			size_t writesize;
	
			delta = ATTR_BUF_SIZE - (filehdr-&gt;entries[0].offset + FINDERINFOSIZE);
			<span class="enscript-keyword">if</span> (ainfop-&gt;rsrcfork &amp;&amp; filehdr-&gt;entries[1].length) {
				<span class="enscript-comment">/* Make some room before existing resource fork. */</span>
				shift_data_down(xvp,
						filehdr-&gt;entries[1].offset,
						filehdr-&gt;entries[1].length,
						delta, context);
				writesize = <span class="enscript-keyword">sizeof</span>(attr_header_t);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Create a new, empty resource fork. */</span>
				rsrcfork_header_t *rsrcforkhdr;
	
				vnode_setsize(xvp, filehdr-&gt;entries[1].offset + delta, 0, context);
	
				<span class="enscript-comment">/* Steal some space for an empty RF header. */</span>
				delta -= <span class="enscript-keyword">sizeof</span>(rsrcfork_header_t);
	
				bzero(&amp;attrhdr-&gt;appledouble.pad[0], delta);
				rsrcforkhdr = (rsrcfork_header_t *)((<span class="enscript-type">char</span> *)filehdr + filehdr-&gt;entries[1].offset + delta);
	
				<span class="enscript-comment">/* Fill in Empty Resource Fork Header. */</span>
				init_empty_resource_fork(rsrcforkhdr);
				
				filehdr-&gt;entries[1].length = <span class="enscript-keyword">sizeof</span>(rsrcfork_header_t);
				writesize = ATTR_BUF_SIZE;
			}
			filehdr-&gt;entries[0].length += delta;
			filehdr-&gt;entries[1].offset += delta;
	
			<span class="enscript-comment">/* Fill in Attribute Header. */</span>
			attrhdr-&gt;magic       = ATTR_HDR_MAGIC;
			attrhdr-&gt;debug_tag   = (u_int32_t)va.va_fileid;
			attrhdr-&gt;total_size  = filehdr-&gt;entries[1].offset;
			attrhdr-&gt;data_start  = <span class="enscript-keyword">sizeof</span>(attr_header_t);
			attrhdr-&gt;data_length = 0;
			attrhdr-&gt;reserved[0] = 0;
			attrhdr-&gt;reserved[1] = 0;
			attrhdr-&gt;reserved[2] = 0;
			attrhdr-&gt;flags       = 0;
			attrhdr-&gt;num_attrs   = 0;
	
			<span class="enscript-comment">/* Push out new header */</span>
			uio_reset(auio, 0, UIO_SYSSPACE, UIO_WRITE);
			uio_addiov(auio, (uintptr_t)filehdr, writesize);
	
			swap_adhdr(filehdr);	<span class="enscript-comment">/* to big endian */</span>
			swap_attrhdr(attrhdr, ainfop);	<span class="enscript-comment">/* to big endian */</span>
			error = VNOP_WRITE(xvp, auio, 0, context);
			swap_adhdr(filehdr);	<span class="enscript-comment">/* back to native */</span>
			<span class="enscript-comment">/* The attribute header gets swapped below. */</span>
		}
	}
	<span class="enscript-comment">/*
	 * Swap and sanity check the extended attribute header and
	 * entries (if any).  The Finder Info content must be big enough
	 * to include the extended attribute header; if not, we just
	 * ignore it.
	 *
	 * Note that we're passing the offset + length (i.e. the end)
	 * of the Finder Info instead of rawsize to validate_attrhdr.
	 * This ensures that all extended attributes lie within the
	 * Finder Info content according to the AppleDouble entry.
	 *
	 * Sets ainfop-&gt;attrhdr and ainfop-&gt;attr_entry if a valid
	 * header was found.
	 */</span>
	<span class="enscript-keyword">if</span> (ainfop-&gt;finderinfo &amp;&amp;
		ainfop-&gt;finderinfo == &amp;filehdr-&gt;entries[0] &amp;&amp;
		ainfop-&gt;finderinfo-&gt;length &gt;= (<span class="enscript-keyword">sizeof</span>(attr_header_t) - <span class="enscript-keyword">sizeof</span>(apple_double_header_t))) {
		attr_header_t *attrhdr = (attr_header_t*)filehdr;

		<span class="enscript-keyword">if</span> ((error = check_and_swap_attrhdr(attrhdr, ainfop)) == 0) {
			ainfop-&gt;attrhdr = attrhdr;  <span class="enscript-comment">/* valid attribute header */</span>
			<span class="enscript-comment">/* First attr_entry starts immediately following attribute header */</span>
			ainfop-&gt;attr_entry = (attr_entry_t *)&amp;attrhdr[1];
		}
	}

	error = 0;
<span class="enscript-reference">bail</span>:
	<span class="enscript-keyword">if</span> (auio != NULL)
		uio_free(auio);
	<span class="enscript-keyword">if</span> (buffer != NULL)
		FREE(buffer, M_TEMP);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">create_xattrfile</span>(vnode_t xvp, u_int32_t fileid, vfs_context_t context)
{
	attr_header_t *xah;
	rsrcfork_header_t *rsrcforkhdr;
	<span class="enscript-type">void</span> * buffer;
	uio_t auio;
	<span class="enscript-type">int</span> rsrcforksize;
	<span class="enscript-type">int</span> error;

	MALLOC(buffer, <span class="enscript-type">void</span> *, ATTR_BUF_SIZE, M_TEMP, M_WAITOK);
	bzero(buffer, ATTR_BUF_SIZE);

	xah = (attr_header_t *)buffer;
	auio = uio_create(1, 0, UIO_SYSSPACE, UIO_WRITE);
	uio_addiov(auio, (uintptr_t)buffer, ATTR_BUF_SIZE);
	rsrcforksize = <span class="enscript-keyword">sizeof</span>(rsrcfork_header_t);
	rsrcforkhdr = (rsrcfork_header_t *) ((<span class="enscript-type">char</span> *)buffer + ATTR_BUF_SIZE - rsrcforksize);

	<span class="enscript-comment">/* Fill in Apple Double Header. */</span>
	xah-&gt;appledouble.magic             = SWAP32 (ADH_MAGIC);
	xah-&gt;appledouble.version           = SWAP32 (ADH_VERSION);
	xah-&gt;appledouble.numEntries        = SWAP16 (2);
	xah-&gt;appledouble.entries[0].type   = SWAP32 (AD_FINDERINFO);
	xah-&gt;appledouble.entries[0].offset = SWAP32 (offsetof(apple_double_header_t, finfo));
	xah-&gt;appledouble.entries[0].length = SWAP32 (ATTR_BUF_SIZE - offsetof(apple_double_header_t, finfo) - rsrcforksize);
	xah-&gt;appledouble.entries[1].type   = SWAP32 (AD_RESOURCE);
	xah-&gt;appledouble.entries[1].offset = SWAP32 (ATTR_BUF_SIZE - rsrcforksize);
	xah-&gt;appledouble.entries[1].length = SWAP32 (rsrcforksize);
	bcopy(ADH_MACOSX, xah-&gt;appledouble.filler, <span class="enscript-keyword">sizeof</span>(xah-&gt;appledouble.filler));

	<span class="enscript-comment">/* Fill in Attribute Header. */</span>
	xah-&gt;magic       = SWAP32 (ATTR_HDR_MAGIC);
	xah-&gt;debug_tag   = SWAP32 (fileid);
	xah-&gt;total_size  = SWAP32 (ATTR_BUF_SIZE - rsrcforksize);
	xah-&gt;data_start  = SWAP32 (<span class="enscript-keyword">sizeof</span>(attr_header_t));

	<span class="enscript-comment">/* Fill in Empty Resource Fork Header. */</span>
	init_empty_resource_fork(rsrcforkhdr);

	<span class="enscript-comment">/* Push it out. */</span>
	error = VNOP_WRITE(xvp, auio, IO_UNIT, context);

	<span class="enscript-comment">/* Did we write out the full uio? */</span>
	<span class="enscript-keyword">if</span> (uio_resid(auio) &gt; 0) {
		error = ENOSPC;
	}

	uio_free(auio);
	FREE(buffer, M_TEMP);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">init_empty_resource_fork</span>(rsrcfork_header_t * rsrcforkhdr)
{
	bzero(rsrcforkhdr, <span class="enscript-keyword">sizeof</span>(rsrcfork_header_t));
	rsrcforkhdr-&gt;fh_DataOffset = SWAP32 (RF_FIRST_RESOURCE);
	rsrcforkhdr-&gt;fh_MapOffset  = SWAP32 (RF_FIRST_RESOURCE);
	rsrcforkhdr-&gt;fh_MapLength  = SWAP32 (RF_NULL_MAP_LENGTH);
	rsrcforkhdr-&gt;mh_DataOffset = SWAP32 (RF_FIRST_RESOURCE);
	rsrcforkhdr-&gt;mh_MapOffset  = SWAP32 (RF_FIRST_RESOURCE);
	rsrcforkhdr-&gt;mh_MapLength  = SWAP32 (RF_NULL_MAP_LENGTH);
	rsrcforkhdr-&gt;mh_Types      = SWAP16 (RF_NULL_MAP_LENGTH - 2 );
	rsrcforkhdr-&gt;mh_Names      = SWAP16 (RF_NULL_MAP_LENGTH);
	rsrcforkhdr-&gt;typeCount     = SWAP16 (-1);
	bcopy(RF_EMPTY_TAG, rsrcforkhdr-&gt;systemData, <span class="enscript-keyword">sizeof</span>(RF_EMPTY_TAG));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rel_xattrinfo</span>(attr_info_t *ainfop)
{
	FREE(ainfop-&gt;filehdr, M_TEMP);
	bzero(ainfop, <span class="enscript-keyword">sizeof</span>(attr_info_t));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">write_xattrinfo</span>(attr_info_t *ainfop)
{
	uio_t auio;
	<span class="enscript-type">int</span> error;

	auio = uio_create(1, 0, UIO_SYSSPACE, UIO_WRITE);
	uio_addiov(auio, (uintptr_t)ainfop-&gt;filehdr, ainfop-&gt;iosize);

	swap_adhdr(ainfop-&gt;filehdr);
	<span class="enscript-keyword">if</span> (ainfop-&gt;attrhdr != NULL) {
		swap_attrhdr(ainfop-&gt;attrhdr, ainfop);
	}

	error = VNOP_WRITE(ainfop-&gt;filevp, auio, 0, ainfop-&gt;context);

	swap_adhdr(ainfop-&gt;filehdr);
	<span class="enscript-keyword">if</span> (ainfop-&gt;attrhdr != NULL) {
		swap_attrhdr(ainfop-&gt;attrhdr, ainfop);
	}
	uio_free(auio);	

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> == <span class="enscript-variable-name">LITTLE_ENDIAN</span>
<span class="enscript-comment">/*
 * Endian swap apple double header 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">swap_adhdr</span>(apple_double_header_t *adh)
{
	<span class="enscript-type">int</span> count;
	<span class="enscript-type">int</span> i;

	count = (adh-&gt;magic == ADH_MAGIC) ? adh-&gt;numEntries : SWAP16(adh-&gt;numEntries);

	adh-&gt;magic      = SWAP32 (adh-&gt;magic);
	adh-&gt;version    = SWAP32 (adh-&gt;version);
	adh-&gt;numEntries = SWAP16 (adh-&gt;numEntries);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		adh-&gt;entries[i].type   = SWAP32 (adh-&gt;entries[i].type);
		adh-&gt;entries[i].offset = SWAP32 (adh-&gt;entries[i].offset);
		adh-&gt;entries[i].length = SWAP32 (adh-&gt;entries[i].length);
	}
}

<span class="enscript-comment">/*
 * Endian swap extended attributes header 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">swap_attrhdr</span>(attr_header_t *ah, attr_info_t* info)
{
	attr_entry_t *ae;
	<span class="enscript-type">int</span> count;
	<span class="enscript-type">int</span> i;

	count = (ah-&gt;magic == ATTR_HDR_MAGIC) ? ah-&gt;num_attrs : SWAP16(ah-&gt;num_attrs);

	ah-&gt;magic       = SWAP32 (ah-&gt;magic);
	ah-&gt;debug_tag   = SWAP32 (ah-&gt;debug_tag);
	ah-&gt;total_size  = SWAP32 (ah-&gt;total_size);
	ah-&gt;data_start  = SWAP32 (ah-&gt;data_start);
	ah-&gt;data_length = SWAP32 (ah-&gt;data_length);
	ah-&gt;flags       = SWAP16 (ah-&gt;flags);
	ah-&gt;num_attrs   = SWAP16 (ah-&gt;num_attrs);

	ae = (attr_entry_t *)(&amp;ah[1]);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; count &amp;&amp; ATTR_VALID(ae, *info); i++, ae = ATTR_NEXT(ae)) {
		ae-&gt;offset = SWAP32 (ae-&gt;offset);
		ae-&gt;length = SWAP32 (ae-&gt;length);
		ae-&gt;flags  = SWAP16 (ae-&gt;flags);
	}
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Validate and swap the attributes header contents, and each attribute's
 * attr_entry_t.
 *
 * Note: Assumes the caller has verified that the Finder Info content is large
 * enough to contain the attr_header structure itself.  Therefore, we can
 * swap the header fields before sanity checking them.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">check_and_swap_attrhdr</span>(attr_header_t *ah, attr_info_t *ainfop)
{
	attr_entry_t *ae;
	u_int8_t *buf_end;
	u_int32_t end;
	<span class="enscript-type">int</span> count;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (ah == NULL)
		<span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-keyword">if</span> (SWAP32(ah-&gt;magic) != ATTR_HDR_MAGIC)
		<span class="enscript-keyword">return</span> EINVAL;
	
	<span class="enscript-comment">/* Swap the basic header fields */</span>
	ah-&gt;magic	= SWAP32(ah-&gt;magic);
	ah-&gt;debug_tag   = SWAP32 (ah-&gt;debug_tag);
	ah-&gt;total_size  = SWAP32 (ah-&gt;total_size);
	ah-&gt;data_start  = SWAP32 (ah-&gt;data_start);
	ah-&gt;data_length = SWAP32 (ah-&gt;data_length);
	ah-&gt;flags       = SWAP16 (ah-&gt;flags);
	ah-&gt;num_attrs   = SWAP16 (ah-&gt;num_attrs);

	<span class="enscript-comment">/*
	 * Make sure the total_size fits within the Finder Info area, and the
	 * extended attribute data area fits within total_size.
	 */</span>
	end = ah-&gt;data_start + ah-&gt;data_length;
	<span class="enscript-keyword">if</span> (ah-&gt;total_size &gt; ainfop-&gt;finderinfo-&gt;offset + ainfop-&gt;finderinfo-&gt;length ||
	    end &lt; ah-&gt;data_start ||
	    end &gt; ah-&gt;total_size) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	<span class="enscript-comment">/*
	 * Make sure each of the attr_entry_t's fits within total_size.
	 */</span>
	buf_end = ainfop-&gt;rawdata + ah-&gt;total_size;
	count = ah-&gt;num_attrs;
	ae = (attr_entry_t *)(&amp;ah[1]);
	
	<span class="enscript-keyword">for</span> (i=0; i&lt;count; i++) {
		<span class="enscript-comment">/* Make sure the fixed-size part of this attr_entry_t fits. */</span>
		<span class="enscript-keyword">if</span> ((u_int8_t *) &amp;ae[1] &gt; buf_end)
			<span class="enscript-keyword">return</span> EINVAL;
		
		<span class="enscript-comment">/* Make sure the variable-length name fits (+1 is for NUL terminator) */</span>
		<span class="enscript-comment">/* TODO: Make sure namelen matches strnlen(name,namelen+1)? */</span>
		<span class="enscript-keyword">if</span> (&amp;ae-&gt;name[ae-&gt;namelen+1] &gt; buf_end)
			<span class="enscript-keyword">return</span> EINVAL;
		
		<span class="enscript-comment">/* Swap the attribute entry fields */</span>
		ae-&gt;offset	= SWAP32(ae-&gt;offset);
		ae-&gt;length	= SWAP32(ae-&gt;length);
		ae-&gt;flags	= SWAP16(ae-&gt;flags);
		
		<span class="enscript-comment">/* Make sure the attribute content fits. */</span>
		end = ae-&gt;offset + ae-&gt;length;
		<span class="enscript-keyword">if</span> (end &lt; ae-&gt;offset || end &gt; ah-&gt;total_size)
			<span class="enscript-keyword">return</span> EINVAL;
		
		ae = ATTR_NEXT(ae);
	}
	
	<span class="enscript-comment">/*
	 * TODO: Make sure the contents of attributes don't overlap the header
	 * and don't overlap each other.  The hard part is that we don't know
	 * what the actual header size is until we have looped over all of the
	 * variable-sized attribute entries.
	 *
	 * XXX  Is there any guarantee that attribute entries are stored in
	 * XXX  order sorted by the contents' file offset?  If so, that would
	 * XXX  make the pairwise overlap check much easier.
	 */</span>

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// &quot;start&quot; &amp; &quot;end&quot; are byte offsets in the file.
</span><span class="enscript-comment">// &quot;to&quot; is the byte offset we want to move the
</span><span class="enscript-comment">// data to.  &quot;to&quot; should be &gt; &quot;start&quot;.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// we do the copy backwards to avoid problems if
</span><span class="enscript-comment">// there's an overlap.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">shift_data_down</span>(vnode_t xvp, off_t start, size_t len, off_t delta, vfs_context_t context)
{
	<span class="enscript-type">int</span> ret, iolen;
	size_t chunk, orig_chunk;
	<span class="enscript-type">char</span> *buff;
	off_t pos;
	kauth_cred_t ucred = vfs_context_ucred(context);
	proc_t p = vfs_context_proc(context);
    
	<span class="enscript-keyword">if</span> (delta == 0 || len == 0) {
		<span class="enscript-keyword">return</span> 0;
	}
	
	chunk = 4096;
	<span class="enscript-keyword">if</span> (len &lt; chunk) {
		chunk = len;
	}
	orig_chunk = chunk;

	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;buff, chunk, VM_KERN_MEMORY_FILE)) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}

	<span class="enscript-keyword">for</span>(pos=start+len-chunk; pos &gt;= start; pos-=chunk) {
		ret = vn_rdwr(UIO_READ, xvp, buff, chunk, pos, UIO_SYSSPACE, IO_NODELOCKED|IO_NOAUTH, ucred, &amp;iolen, p);
		<span class="enscript-keyword">if</span> (iolen != 0) {
			printf(<span class="enscript-string">&quot;xattr:shift_data: error reading data @ %lld (read %d of %lu) (%d)\n&quot;</span>,
				pos, ret, chunk, ret);
			<span class="enscript-keyword">break</span>;
		}
		
		ret = vn_rdwr(UIO_WRITE, xvp, buff, chunk, pos + delta, UIO_SYSSPACE, IO_NODELOCKED|IO_NOAUTH, ucred, &amp;iolen, p);
		<span class="enscript-keyword">if</span> (iolen != 0) {
			printf(<span class="enscript-string">&quot;xattr:shift_data: error writing data @ %lld (wrote %d of %lu) (%d)\n&quot;</span>,
				pos+delta, ret, chunk, ret);
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">if</span> ((pos - (off_t)chunk) &lt; start) {
			chunk = pos - start;
	    
			<span class="enscript-keyword">if</span> (chunk == 0) {   <span class="enscript-comment">// we're all done
</span>				<span class="enscript-keyword">break</span>;
			}
		}
	}
	kmem_free(kernel_map, (vm_offset_t)buff, orig_chunk);

	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">shift_data_up</span>(vnode_t xvp, off_t start, size_t len, off_t delta, vfs_context_t context)
{
	<span class="enscript-type">int</span> ret, iolen;
	size_t chunk, orig_chunk;
	<span class="enscript-type">char</span> *buff;
	off_t pos;
	off_t end;
	kauth_cred_t ucred = vfs_context_ucred(context);
	proc_t p = vfs_context_proc(context);
    
	<span class="enscript-keyword">if</span> (delta == 0 || len == 0) {
		<span class="enscript-keyword">return</span> 0;
	}
	
	chunk = 4096;
	<span class="enscript-keyword">if</span> (len &lt; chunk) {
		chunk = len;
	}
	orig_chunk = chunk;
	end = start + len;

	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;buff, chunk, VM_KERN_MEMORY_FILE)) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}

	<span class="enscript-keyword">for</span>(pos = start; pos &lt; end; pos += chunk) {
		ret = vn_rdwr(UIO_READ, xvp, buff, chunk, pos, UIO_SYSSPACE, IO_NODELOCKED|IO_NOAUTH, ucred, &amp;iolen, p);
		<span class="enscript-keyword">if</span> (iolen != 0) {
			printf(<span class="enscript-string">&quot;xattr:shift_data: error reading data @ %lld (read %d of %lu) (%d)\n&quot;</span>,
				pos, ret, chunk, ret);
			<span class="enscript-keyword">break</span>;
		}
		
		ret = vn_rdwr(UIO_WRITE, xvp, buff, chunk, pos - delta, UIO_SYSSPACE, IO_NODELOCKED|IO_NOAUTH, ucred, &amp;iolen, p);
		<span class="enscript-keyword">if</span> (iolen != 0) {
			printf(<span class="enscript-string">&quot;xattr:shift_data: error writing data @ %lld (wrote %d of %lu) (%d)\n&quot;</span>,
				pos+delta, ret, chunk, ret);
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">if</span> ((pos + (off_t)chunk) &gt; end) {
			chunk = end - pos;
	    
			<span class="enscript-keyword">if</span> (chunk == 0) {   <span class="enscript-comment">// we're all done
</span>				<span class="enscript-keyword">break</span>;
			}
		}
	}
	kmem_free(kernel_map, (vm_offset_t)buff, orig_chunk);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lock_xattrfile</span>(vnode_t xvp, <span class="enscript-type">short</span> locktype, vfs_context_t context)
{
	<span class="enscript-type">struct</span> flock lf;
	<span class="enscript-type">int</span> error;

	lf.l_whence = SEEK_SET;
	lf.l_start = 0;
	lf.l_len = 0;
	lf.l_type = locktype; <span class="enscript-comment">/* F_WRLCK or F_RDLCK */</span>
	<span class="enscript-comment">/* Note: id is just a kernel address that's not a proc */</span>
	error = VNOP_ADVLOCK(xvp, (caddr_t)xvp, F_SETLK, &amp;lf, F_FLOCK|F_WAIT, context, NULL);
	<span class="enscript-keyword">return</span> (error == ENOTSUP ? 0 : error);
}

 <span class="enscript-type">int</span>
<span class="enscript-function-name">unlock_xattrfile</span>(vnode_t xvp, vfs_context_t context)
{
	<span class="enscript-type">struct</span> flock lf;
	<span class="enscript-type">int</span> error;

	lf.l_whence = SEEK_SET;
	lf.l_start = 0;
	lf.l_len = 0;
	lf.l_type = F_UNLCK;
	<span class="enscript-comment">/* Note: id is just a kernel address that's not a proc */</span>
	error = VNOP_ADVLOCK(xvp, (caddr_t)xvp, F_UNLCK, &amp;lf, F_FLOCK, context, NULL);
	<span class="enscript-keyword">return</span> (error == ENOTSUP ? 0 : error);
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_getxattr</span>(__unused vnode_t vp, __unused <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
    __unused uio_t uio, __unused size_t *size, __unused <span class="enscript-type">int</span> options,
    __unused vfs_context_t context)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_setxattr</span>(__unused vnode_t vp, __unused <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
    __unused uio_t uio, __unused <span class="enscript-type">int</span> options, __unused vfs_context_t context)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_listxattr</span>(__unused vnode_t vp,
    __unused uio_t uio, __unused size_t *size, __unused <span class="enscript-type">int</span> options,
    __unused vfs_context_t context)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_removexattr</span>(__unused vnode_t vp, __unused <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
   __unused <span class="enscript-type">int</span> options, __unused vfs_context_t context)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>
</pre>
<hr />
</body></html>