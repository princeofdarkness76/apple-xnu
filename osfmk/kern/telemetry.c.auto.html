<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>telemetry.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">telemetry.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_special_ports.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/telemetry_notification_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span> 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span> 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span> 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/telemetry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer_call.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_shared_region.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/kperf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/context.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/callstack.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;uuid/uuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_dyld.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TELEMETRY_DEBUG</span> 0

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	proc_pid(<span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">char</span>	*proc_name_address(<span class="enscript-type">void</span> *p);
<span class="enscript-type">extern</span> uint64_t <span class="enscript-function-name">proc_uniqueid</span>(<span class="enscript-type">void</span> *p);
<span class="enscript-type">extern</span> uint64_t <span class="enscript-function-name">proc_was_throttled</span>(<span class="enscript-type">void</span> *p);
<span class="enscript-type">extern</span> uint64_t <span class="enscript-function-name">proc_did_throttle</span>(<span class="enscript-type">void</span> *p);
<span class="enscript-type">extern</span> uint64_t <span class="enscript-function-name">get_dispatchqueue_serialno_offset_from_proc</span>(<span class="enscript-type">void</span> *p);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	proc_selfpid(<span class="enscript-type">void</span>);

<span class="enscript-type">struct</span> micro_snapshot_buffer {
	vm_offset_t		buffer;
	uint32_t		size;
	uint32_t		current_position;
	uint32_t		end_point;
};

<span class="enscript-type">void</span> <span class="enscript-function-name">telemetry_take_sample</span>(thread_t thread, uint8_t microsnapshot_flags, <span class="enscript-type">struct</span> micro_snapshot_buffer * current_buffer);
<span class="enscript-type">int</span> <span class="enscript-function-name">telemetry_buffer_gather</span>(user_addr_t buffer, uint32_t *length, boolean_t mark, <span class="enscript-type">struct</span> micro_snapshot_buffer * current_buffer);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TELEMETRY_DEFAULT_SAMPLE_RATE</span> (1) <span class="enscript-comment">/* 1 sample every 1 second */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TELEMETRY_DEFAULT_WINDOW_BUFFER_SIZE</span> (512*1024) <span class="enscript-comment">/* Should hopefully provide 10 seconds worth of samples */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TELEMETRY_DEFAULT_BUFFER_SIZE</span> (16*1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TELEMETRY_MAX_BUFFER_SIZE</span> (64*1024)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TELEMETRY_DEFAULT_NOTIFY_LEEWAY</span> (4*1024) // Userland gets 4k of leeway to collect data after notification
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TELEMETRY_MAX_UUID_COUNT</span> (128) // Max of 128 non-shared-cache UUIDs to log for symbolication

uint32_t 			telemetry_sample_rate = 0;
<span class="enscript-type">volatile</span> boolean_t 	telemetry_needs_record = FALSE;
<span class="enscript-type">volatile</span> boolean_t	telemetry_windowed_record = FALSE;
<span class="enscript-type">volatile</span> boolean_t 	telemetry_needs_timer_arming_record = FALSE;

<span class="enscript-comment">/*
 * Tells the scheduler that we want it to invoke
 * compute_telemetry_windowed(); it is still our responsibility
 * to ensure that we do not panic if someone disables the window
 * buffer immediately after the scheduler does so.
 */</span>
<span class="enscript-type">volatile</span> boolean_t	telemetry_window_enabled = FALSE;

<span class="enscript-comment">/*
 * If TRUE, record micro-stackshot samples for all tasks.
 * If FALSE, only sample tasks which are marked for telemetry.
 */</span>
boolean_t			telemetry_sample_all_tasks = FALSE;
uint32_t			telemetry_active_tasks = 0; <span class="enscript-comment">// Number of tasks opted into telemetry
</span>
uint32_t			telemetry_timestamp = 0;

<span class="enscript-comment">/*
 * We have two buffers.  The telemetry_buffer is responsible
 * for timer samples and interrupt samples that are driven by
 * compute_averages().  It will notify its client (if one
 * exists) when it has enough data to be worth flushing.
 *
 * The window_buffer contains only interrupt_samples that are
 * driven by the scheduler.  Its intent is to provide a
 * window of recent activity on the cpu(s).
 */</span>
<span class="enscript-type">struct</span> micro_snapshot_buffer telemetry_buffer = {0, 0, 0, 0};
<span class="enscript-type">struct</span> micro_snapshot_buffer window_buffer = {0, 0, 0, 0};

<span class="enscript-type">int</span>					telemetry_bytes_since_last_mark = -1; <span class="enscript-comment">// How much data since buf was last marked?
</span><span class="enscript-type">int</span>					telemetry_buffer_notify_at = 0;

lck_grp_t       	telemetry_lck_grp;
lck_mtx_t       	telemetry_mtx;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TELEMETRY_LOCK</span>() do { lck_mtx_lock(&amp;telemetry_mtx); } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TELEMETRY_TRY_SPIN_LOCK</span>() lck_mtx_try_lock_spin(&amp;telemetry_mtx)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TELEMETRY_UNLOCK</span>() do { lck_mtx_unlock(&amp;telemetry_mtx); } while(0)

<span class="enscript-type">void</span> <span class="enscript-function-name">telemetry_init</span>(<span class="enscript-type">void</span>)
{
	kern_return_t ret;
	uint32_t	  telemetry_notification_leeway;

	lck_grp_init(&amp;telemetry_lck_grp, <span class="enscript-string">&quot;telemetry group&quot;</span>, LCK_GRP_ATTR_NULL);
	lck_mtx_init(&amp;telemetry_mtx, &amp;telemetry_lck_grp, LCK_ATTR_NULL);

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;telemetry_buffer_size&quot;</span>, &amp;telemetry_buffer.size, <span class="enscript-keyword">sizeof</span>(telemetry_buffer.size))) {
		telemetry_buffer.size = TELEMETRY_DEFAULT_BUFFER_SIZE;
	}

	<span class="enscript-keyword">if</span> (telemetry_buffer.size &gt; TELEMETRY_MAX_BUFFER_SIZE)
		telemetry_buffer.size = TELEMETRY_MAX_BUFFER_SIZE;

	ret = kmem_alloc(kernel_map, &amp;telemetry_buffer.buffer, telemetry_buffer.size, VM_KERN_MEMORY_DIAG);
	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS) {
		kprintf(<span class="enscript-string">&quot;Telemetry: Allocation failed: %d\n&quot;</span>, ret);
		<span class="enscript-keyword">return</span>;
	}
	bzero((<span class="enscript-type">void</span> *) telemetry_buffer.buffer, telemetry_buffer.size);

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;telemetry_notification_leeway&quot;</span>, &amp;telemetry_notification_leeway, <span class="enscript-keyword">sizeof</span>(telemetry_notification_leeway))) {
		<span class="enscript-comment">/*
		 * By default, notify the user to collect the buffer when there is this much space left in the buffer.
		 */</span>
		telemetry_notification_leeway = TELEMETRY_DEFAULT_NOTIFY_LEEWAY;
	}
	<span class="enscript-keyword">if</span> (telemetry_notification_leeway &gt;= telemetry_buffer.size) {
		printf(<span class="enscript-string">&quot;telemetry: nonsensical telemetry_notification_leeway boot-arg %d changed to %d\n&quot;</span>,
		       telemetry_notification_leeway, TELEMETRY_DEFAULT_NOTIFY_LEEWAY);
		telemetry_notification_leeway = TELEMETRY_DEFAULT_NOTIFY_LEEWAY;
	}
	telemetry_buffer_notify_at = telemetry_buffer.size - telemetry_notification_leeway;

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;telemetry_sample_rate&quot;</span>, &amp;telemetry_sample_rate, <span class="enscript-keyword">sizeof</span>(telemetry_sample_rate))) {
		telemetry_sample_rate = TELEMETRY_DEFAULT_SAMPLE_RATE;
	}

	<span class="enscript-comment">/*
	 * To enable telemetry for all tasks, include &quot;telemetry_sample_all_tasks=1&quot; in boot-args.
	 */</span>
	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;telemetry_sample_all_tasks&quot;</span>, &amp;telemetry_sample_all_tasks, <span class="enscript-keyword">sizeof</span>(telemetry_sample_all_tasks))) {

		telemetry_sample_all_tasks = TRUE;

	}

	kprintf(<span class="enscript-string">&quot;Telemetry: Sampling %stasks once per %u second%s\n&quot;</span>,
		(telemetry_sample_all_tasks) ? <span class="enscript-string">&quot;all &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		telemetry_sample_rate, telemetry_sample_rate == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>);
}

<span class="enscript-comment">/*
 * Enable or disable global microstackshots (ie telemetry_sample_all_tasks).
 *
 * enable_disable == 1: turn it on
 * enable_disable == 0: turn it off
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">telemetry_global_ctl</span>(<span class="enscript-type">int</span> enable_disable) 
{
	<span class="enscript-keyword">if</span> (enable_disable == 1) {
		telemetry_sample_all_tasks = TRUE;
	} <span class="enscript-keyword">else</span> {
		telemetry_sample_all_tasks = FALSE;
	}
}

<span class="enscript-comment">/*
 * Opt the given task into or out of the telemetry stream.
 *
 * Supported reasons (callers may use any or all of):
 *     TF_CPUMON_WARNING
 *     TF_WAKEMON_WARNING
 *
 * enable_disable == 1: turn it on
 * enable_disable == 0: turn it off
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">telemetry_task_ctl</span>(task_t task, uint32_t reasons, <span class="enscript-type">int</span> enable_disable)
{
	task_lock(task);
	telemetry_task_ctl_locked(task, reasons, enable_disable);
	task_unlock(task);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">telemetry_task_ctl_locked</span>(task_t task, uint32_t reasons, <span class="enscript-type">int</span> enable_disable)
{
	uint32_t origflags;

	assert((reasons != 0) &amp;&amp; ((reasons | TF_TELEMETRY) == TF_TELEMETRY));

	task_lock_assert_owned(task);

	origflags = task-&gt;t_flags;

	<span class="enscript-keyword">if</span> (enable_disable == 1) {
		task-&gt;t_flags |= reasons;
		<span class="enscript-keyword">if</span> ((origflags &amp; TF_TELEMETRY) == 0) {
			OSIncrementAtomic(&amp;telemetry_active_tasks);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TELEMETRY_DEBUG</span>			
			printf(<span class="enscript-string">&quot;%s: telemetry OFF -&gt; ON (%d active)\n&quot;</span>, proc_name_address(task-&gt;bsd_info), telemetry_active_tasks);
#<span class="enscript-reference">endif</span>			
		}
	} <span class="enscript-keyword">else</span> {
		task-&gt;t_flags &amp;= ~reasons;
		<span class="enscript-keyword">if</span> (((origflags &amp; TF_TELEMETRY) != 0) &amp;&amp; ((task-&gt;t_flags &amp; TF_TELEMETRY) == 0)) {
			<span class="enscript-comment">/*
			 * If this task went from having at least one telemetry bit to having none,
			 * the net change was to disable telemetry for the task.
			 */</span>
			OSDecrementAtomic(&amp;telemetry_active_tasks);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TELEMETRY_DEBUG</span>
			printf(<span class="enscript-string">&quot;%s: telemetry ON -&gt; OFF (%d active)\n&quot;</span>, proc_name_address(task-&gt;bsd_info), telemetry_active_tasks);
#<span class="enscript-reference">endif</span>
		}
	}
}

<span class="enscript-comment">/*
 * Enable the window_buffer, and do any associated setup.
 */</span>
kern_return_t
<span class="enscript-function-name">telemetry_enable_window</span>(<span class="enscript-type">void</span>)
{
	kern_return_t ret = KERN_SUCCESS;
	vm_offset_t kern_buffer = 0;
	vm_size_t kern_buffer_size = TELEMETRY_DEFAULT_WINDOW_BUFFER_SIZE;

	<span class="enscript-comment">/*
	 * We have no guarantee we won't allocate the buffer, take
	 * the lock, and then discover someone beat us to the punch,
	 * but we would prefer to avoid blocking while holding the
	 * lock.
	 */</span>
	ret = kmem_alloc(kernel_map, &amp;kern_buffer, kern_buffer_size, VM_KERN_MEMORY_DIAG);

	TELEMETRY_LOCK();

	<span class="enscript-keyword">if</span> (!window_buffer.buffer) {
		<span class="enscript-keyword">if</span> (ret == KERN_SUCCESS) {
			<span class="enscript-comment">/* No existing buffer was found, so... */</span>
			window_buffer.end_point = 0;
			window_buffer.current_position = 0;
	
			<span class="enscript-comment">/* Hand off the buffer, and... */</span>
			window_buffer.size = (uint32_t) kern_buffer_size;
			window_buffer.buffer = kern_buffer;
			kern_buffer = 0;
			kern_buffer_size = 0;
			bzero((<span class="enscript-type">void</span> *) window_buffer.buffer, window_buffer.size);
	
			<span class="enscript-comment">/* Let the scheduler know it should drive windowed samples */</span>
			telemetry_window_enabled = TRUE;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* We already have a buffer, so we have &quot;succeeded&quot; */</span>
		ret = KERN_SUCCESS;
	}

	TELEMETRY_UNLOCK();

	<span class="enscript-keyword">if</span> (kern_buffer)
		kmem_free(kernel_map, kern_buffer, kern_buffer_size);

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/*
 * Disable the window_buffer, and do any associated teardown.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">telemetry_disable_window</span>(<span class="enscript-type">void</span>)
{
	vm_offset_t kern_buffer = 0;
	vm_size_t kern_buffer_size = 0;

	TELEMETRY_LOCK();

	<span class="enscript-keyword">if</span> (window_buffer.buffer) {
		<span class="enscript-comment">/* We have a window buffer, so tear it down */</span>
		telemetry_window_enabled = FALSE;
		kern_buffer = window_buffer.buffer;
		kern_buffer_size = window_buffer.size;
		window_buffer.buffer = 0;
		window_buffer.size = 0;
		window_buffer.current_position = 0;
		window_buffer.end_point = 0;
	}

	TELEMETRY_UNLOCK();

	<span class="enscript-keyword">if</span> (kern_buffer)
		kmem_free(kernel_map, kern_buffer, kern_buffer_size);
}

<span class="enscript-comment">/*
 * Determine if the current thread is eligible for telemetry:
 *
 * telemetry_sample_all_tasks: All threads are eligible. This takes precedence.
 * telemetry_active_tasks: Count of tasks opted in.
 * task-&gt;t_flags &amp; TF_TELEMETRY: This task is opted in.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">telemetry_is_active</span>(thread_t thread)
{
	task_t task = thread-&gt;task;

	<span class="enscript-keyword">if</span> (task == kernel_task) {
		<span class="enscript-comment">/* Kernel threads never return to an AST boundary, and are ineligible */</span>
		<span class="enscript-keyword">return</span> FALSE;
	}

	<span class="enscript-keyword">if</span> (telemetry_sample_all_tasks == TRUE) {
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">if</span> ((telemetry_active_tasks &gt; 0) &amp;&amp; ((thread-&gt;task-&gt;t_flags &amp; TF_TELEMETRY) != 0)) {
		<span class="enscript-keyword">return</span> (TRUE);
	}
 
	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-comment">/*
 * Userland is arming a timer. If we are eligible for such a record,
 * sample now. No need to do this one at the AST because we're already at
 * a safe place in this system call.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">telemetry_timer_event</span>(__unused uint64_t deadline, __unused uint64_t interval, __unused uint64_t leeway)
{
	<span class="enscript-keyword">if</span> (telemetry_needs_timer_arming_record == TRUE) {
		telemetry_needs_timer_arming_record = FALSE;
		telemetry_take_sample(current_thread(), kTimerArmingRecord | kUserMode, &amp;telemetry_buffer);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Mark the current thread for an interrupt-based
 * telemetry record, to be sampled at the next AST boundary.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">telemetry_mark_curthread</span>(boolean_t interrupted_userspace)
{
	uint32_t ast_bits = 0;
	thread_t thread = current_thread();

	<span class="enscript-comment">/*
	 * If telemetry isn't active for this thread, return and try
	 * again next time.
	 */</span>
	<span class="enscript-keyword">if</span> (telemetry_is_active(thread) == FALSE) {
		<span class="enscript-keyword">return</span>;
	}

	ast_bits |= (interrupted_userspace ? AST_TELEMETRY_USER : AST_TELEMETRY_KERNEL);

	<span class="enscript-keyword">if</span> (telemetry_windowed_record) {
		ast_bits |= AST_TELEMETRY_WINDOWED;
	}

	telemetry_windowed_record = FALSE;
	telemetry_needs_record = FALSE;
	thread_ast_set(thread, ast_bits);
	ast_propagate(thread-&gt;ast);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">compute_telemetry</span>(<span class="enscript-type">void</span> *arg __unused)
{
	<span class="enscript-keyword">if</span> (telemetry_sample_all_tasks || (telemetry_active_tasks &gt; 0)) {
		<span class="enscript-keyword">if</span> ((++telemetry_timestamp) % telemetry_sample_rate == 0) {
			telemetry_needs_record = TRUE;
			telemetry_needs_timer_arming_record = TRUE;
		}
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">compute_telemetry_windowed</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (telemetry_sample_all_tasks || (telemetry_active_tasks &gt; 0)) {
		<span class="enscript-comment">/*
		 * Due to the relationship between the two fields here,
		 * a request for a windowed record will &quot;squash&quot; a
		 * request for a regular interrupt record.  We hedge
		 * against this by doing a quick check for an existing
		 * request.  compute_telemetry doesn't hedge because
		 * a regular request cannot squash a windowed request
		 * (due to the implementation).
		 *
		 * If we really want to do this properly, we could make
		 * telemetry_needs_record a bitfield, and process one
		 * request per telemetry_mark_curthread... but that
		 * would be more expensive (atomics).  This should be
		 * robust enough for now (although it biases in favor
		 * of the regular records).
		 */</span>
		<span class="enscript-keyword">if</span> (!telemetry_needs_record) {
			telemetry_needs_record = TRUE;
			telemetry_windowed_record = TRUE;
		}
	}
}

<span class="enscript-comment">/*
 * If userland has registered a port for telemetry notifications, send one now.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">telemetry_notify_user</span>(<span class="enscript-type">void</span>)
{
	mach_port_t user_port;
	uint32_t	flags = 0;
	<span class="enscript-type">int</span>			error;

	error = host_get_telemetry_port(host_priv_self(), &amp;user_port);
	<span class="enscript-keyword">if</span> ((error != KERN_SUCCESS) || !IPC_PORT_VALID(user_port)) {
		<span class="enscript-keyword">return</span>;
	}

	telemetry_notification(user_port, flags);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">telemetry_ast</span>(thread_t thread, boolean_t interrupted_userspace, boolean_t is_windowed)
{
	uint8_t microsnapshot_flags = kInterruptRecord;

	<span class="enscript-keyword">if</span> (interrupted_userspace)
		microsnapshot_flags |= kUserMode;

	<span class="enscript-keyword">if</span> (is_windowed) {
		telemetry_take_sample(thread, microsnapshot_flags, &amp;window_buffer);
	} <span class="enscript-keyword">else</span> {
		telemetry_take_sample(thread, microsnapshot_flags, &amp;telemetry_buffer);
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">telemetry_take_sample</span>(thread_t thread, uint8_t microsnapshot_flags, <span class="enscript-type">struct</span> micro_snapshot_buffer * current_buffer)
{
	task_t task;
	<span class="enscript-type">void</span> *p;
	<span class="enscript-type">struct</span> kperf_context ctx;
	<span class="enscript-type">struct</span> callstack cs;
	uint32_t btcount, bti;
	<span class="enscript-type">struct</span> micro_snapshot *msnap;
	<span class="enscript-type">struct</span> task_snapshot *tsnap;
	<span class="enscript-type">struct</span> thread_snapshot *thsnap;
	clock_sec_t secs;
	clock_usec_t usecs;
	vm_size_t framesize;
	uint32_t current_record_start;
	uint32_t tmp = 0;
	boolean_t notify = FALSE;

	<span class="enscript-keyword">if</span> (thread == THREAD_NULL)
		<span class="enscript-keyword">return</span>;

	task = thread-&gt;task;
	<span class="enscript-keyword">if</span> ((task == TASK_NULL) || (task == kernel_task))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * To avoid overloading the system with telemetry requests, make
	 * sure we don't add more requests while existing ones are
	 * in-flight.  Attempt this by checking if we can grab the lock.
	 *
	 * This concerns me a little; this working as intended is
	 * contingent on the workload being done in the context of the
	 * telemetry lock being the expensive part of telemetry.  This
	 * includes populating the buffer and the client gathering it,
	 * but excludes the copyin overhead.
	 */</span>
	<span class="enscript-keyword">if</span> (!TELEMETRY_TRY_SPIN_LOCK())
		<span class="enscript-keyword">return</span>;

	TELEMETRY_UNLOCK();

	<span class="enscript-comment">/* telemetry_XXX accessed outside of lock for instrumentation only */</span>
	<span class="enscript-comment">/* TODO */</span>
	KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_STACKSHOT, MICROSTACKSHOT_RECORD) | DBG_FUNC_START, microsnapshot_flags, telemetry_bytes_since_last_mark, 0, 0, (&amp;telemetry_buffer != current_buffer));

	p = get_bsdtask_info(task);

	ctx.cur_thread = thread;
	ctx.cur_pid = proc_pid(p);

	<span class="enscript-comment">/*
	 * Gather up the data we'll need for this sample. The sample is written into the kernel
	 * buffer with the global telemetry lock held -- so we must do our (possibly faulting)
	 * copies from userland here, before taking the lock.
	 */</span>
	kperf_ucallstack_sample(&amp;cs, &amp;ctx);
	<span class="enscript-keyword">if</span> (!(cs.flags &amp; CALLSTACK_VALID))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Find the actual [slid] address of the shared cache's UUID, and copy it in from userland.
	 */</span>
	<span class="enscript-type">int</span>		 					shared_cache_uuid_valid = 0;
	uint64_t					shared_cache_base_address;
	<span class="enscript-type">struct</span> _dyld_cache_header	shared_cache_header;
	uint64_t					shared_cache_slide;

	<span class="enscript-comment">/*
	 * Don't copy in the entire shared cache header; we only need the UUID. Calculate the
	 * offset of that one field.
	 */</span>
	<span class="enscript-type">int</span> sc_header_uuid_offset = (<span class="enscript-type">char</span> *)&amp;shared_cache_header.uuid - (<span class="enscript-type">char</span> *)&amp;shared_cache_header;
	vm_shared_region_t sr = vm_shared_region_get(task);
	<span class="enscript-keyword">if</span> (sr != NULL) {
		<span class="enscript-keyword">if</span> ((vm_shared_region_start_address(sr, &amp;shared_cache_base_address) == KERN_SUCCESS) &amp;&amp;
			(copyin(shared_cache_base_address + sc_header_uuid_offset, (<span class="enscript-type">char</span> *)&amp;shared_cache_header.uuid,
	    	    <span class="enscript-keyword">sizeof</span> (shared_cache_header.uuid)) == 0)) {
			shared_cache_uuid_valid = 1;
			shared_cache_slide = vm_shared_region_get_slide(sr);
		}
		<span class="enscript-comment">// vm_shared_region_get() gave us a reference on the shared region.
</span>		vm_shared_region_deallocate(sr);
	}

	<span class="enscript-comment">/*
	 * Retrieve the array of UUID'sÂ for binaries used by this task.
	 * We reach down into DYLD's data structures to find the array.
	 *
	 * XXX - make this common with kdp?
	 */</span>
	uint32_t			uuid_info_count = 0;
	mach_vm_address_t	uuid_info_addr = 0;
	<span class="enscript-keyword">if</span> (task_has_64BitAddr(task)) {
		<span class="enscript-type">struct</span> user64_dyld_all_image_infos task_image_infos;
		<span class="enscript-keyword">if</span> (copyin(task-&gt;all_image_info_addr, (<span class="enscript-type">char</span> *)&amp;task_image_infos, <span class="enscript-keyword">sizeof</span>(task_image_infos)) == 0) {
			uuid_info_count = (uint32_t)task_image_infos.uuidArrayCount;
			uuid_info_addr = task_image_infos.uuidArray;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_dyld_all_image_infos task_image_infos;
		<span class="enscript-keyword">if</span> (copyin(task-&gt;all_image_info_addr, (<span class="enscript-type">char</span> *)&amp;task_image_infos, <span class="enscript-keyword">sizeof</span>(task_image_infos)) == 0) {
			uuid_info_count = task_image_infos.uuidArrayCount;
			uuid_info_addr = task_image_infos.uuidArray;
		}
	}

	<span class="enscript-comment">/*
	 * If we get a NULL uuid_info_addr (which can happen when we catch dyld in the middle of updating
	 * this data structure), we zero the uuid_info_count so that we won't even try to save load info
	 * for this task.
	 */</span>
	<span class="enscript-keyword">if</span> (!uuid_info_addr) {
		uuid_info_count = 0;
	}

	<span class="enscript-comment">/*
	 * Don't copy in an unbounded amount of memory. The main binary and interesting
	 * non-shared-cache libraries should be in the first few images.
	 */</span>
	<span class="enscript-keyword">if</span> (uuid_info_count &gt; TELEMETRY_MAX_UUID_COUNT) {
		uuid_info_count = TELEMETRY_MAX_UUID_COUNT;
	}

	uint32_t uuid_info_size = (uint32_t)(task_has_64BitAddr(thread-&gt;task) ? <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_dyld_uuid_info) : <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_dyld_uuid_info));
	uint32_t uuid_info_array_size = uuid_info_count * uuid_info_size;
	<span class="enscript-type">char</span>	 *uuid_info_array = NULL;

	<span class="enscript-keyword">if</span> (uuid_info_count &gt; 0) {
		<span class="enscript-keyword">if</span> ((uuid_info_array = (<span class="enscript-type">char</span> *)kalloc(uuid_info_array_size)) == NULL) {
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/*
		 * Copy in the UUID info array.
		 * It may be nonresident, in which case just fix up nloadinfos to 0 in the task snapshot.
		 */</span>
		<span class="enscript-keyword">if</span> (copyin(uuid_info_addr, uuid_info_array, uuid_info_array_size) != 0) {
			kfree(uuid_info_array, uuid_info_array_size);
			uuid_info_array = NULL;
			uuid_info_array_size = 0;
		}
	}

	<span class="enscript-comment">/*
	 * Look for a dispatch queue serial number, and copy it in from userland if present.
	 */</span>
	uint64_t dqserialnum = 0;
	<span class="enscript-type">int</span>		 dqserialnum_valid = 0;

	uint64_t dqkeyaddr = thread_dispatchqaddr(thread);
	<span class="enscript-keyword">if</span> (dqkeyaddr != 0) {
		uint64_t dqaddr = 0;
		uint64_t dq_serialno_offset = get_dispatchqueue_serialno_offset_from_proc(task-&gt;bsd_info);
		<span class="enscript-keyword">if</span> ((copyin(dqkeyaddr, (<span class="enscript-type">char</span> *)&amp;dqaddr, (task_has_64BitAddr(task) ? 8 : 4)) == 0) &amp;&amp;
		    (dqaddr != 0) &amp;&amp; (dq_serialno_offset != 0)) {
			uint64_t dqserialnumaddr = dqaddr + dq_serialno_offset;
			<span class="enscript-keyword">if</span> (copyin(dqserialnumaddr, (<span class="enscript-type">char</span> *)&amp;dqserialnum, (task_has_64BitAddr(task) ? 8 : 4)) == 0) {
				dqserialnum_valid = 1;
			}
		}
	}

	clock_get_calendar_microtime(&amp;secs, &amp;usecs);

	TELEMETRY_LOCK();

	<span class="enscript-comment">/*
	 * For the benefit of the window buffer; if our buffer is not backed by anything,
	 * then we cannot take the sample.  Meant to allow us to deallocate the window
	 * buffer if it is disabled.
	 */</span>
	<span class="enscript-keyword">if</span> (!current_buffer-&gt;buffer)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel_sample</span>;

	<span class="enscript-comment">/*
	 * We do the bulk of the operation under the telemetry lock, on assumption that
	 * any page faults during execution will not cause another AST_TELEMETRY_ALL
	 * to deadlock; they will just block until we finish. This makes it easier
	 * to copy into the buffer directly. As soon as we unlock, userspace can copy
	 * out of our buffer.
	 */</span>

<span class="enscript-reference">copytobuffer</span>:

	current_record_start = current_buffer-&gt;current_position;

	<span class="enscript-keyword">if</span> ((current_buffer-&gt;size - current_buffer-&gt;current_position) &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> micro_snapshot)) {
		<span class="enscript-comment">/*
		 * We can't fit a record in the space available, so wrap around to the beginning.
		 * Save the current position as the known end point of valid data.
		 */</span>
		current_buffer-&gt;end_point = current_record_start;
		current_buffer-&gt;current_position = 0;
		<span class="enscript-keyword">if</span> (current_record_start == 0) {
			<span class="enscript-comment">/* This sample is too large to fit in the buffer even when we started at 0, so skip it */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel_sample</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">copytobuffer</span>;
	}

	msnap = (<span class="enscript-type">struct</span> micro_snapshot *)(uintptr_t)(current_buffer-&gt;buffer + current_buffer-&gt;current_position);
	msnap-&gt;snapshot_magic = STACKSHOT_MICRO_SNAPSHOT_MAGIC;
	msnap-&gt;ms_flags = microsnapshot_flags;
	msnap-&gt;ms_opaque_flags = 0; <span class="enscript-comment">/* namespace managed by userspace */</span>
	msnap-&gt;ms_cpu = 0; <span class="enscript-comment">/* XXX - does this field make sense for a micro-stackshot? */</span>
	msnap-&gt;ms_time = secs;
	msnap-&gt;ms_time_microsecs = usecs;

	current_buffer-&gt;current_position += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> micro_snapshot);

	<span class="enscript-keyword">if</span> ((current_buffer-&gt;size - current_buffer-&gt;current_position) &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> task_snapshot)) {
		current_buffer-&gt;end_point = current_record_start;
		current_buffer-&gt;current_position = 0;
		<span class="enscript-keyword">if</span> (current_record_start == 0) {
			<span class="enscript-comment">/* This sample is too large to fit in the buffer even when we started at 0, so skip it */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel_sample</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">copytobuffer</span>;
	}

	tsnap = (<span class="enscript-type">struct</span> task_snapshot *)(uintptr_t)(current_buffer-&gt;buffer + current_buffer-&gt;current_position);
	bzero(tsnap, <span class="enscript-keyword">sizeof</span>(*tsnap));
	tsnap-&gt;snapshot_magic = STACKSHOT_TASK_SNAPSHOT_MAGIC;
	tsnap-&gt;pid = proc_pid(p);
	tsnap-&gt;uniqueid = proc_uniqueid(p);
	tsnap-&gt;user_time_in_terminated_threads = task-&gt;total_user_time;
	tsnap-&gt;system_time_in_terminated_threads = task-&gt;total_system_time;
	tsnap-&gt;suspend_count = task-&gt;suspend_count;
	tsnap-&gt;task_size = pmap_resident_count(task-&gt;map-&gt;pmap);
	tsnap-&gt;faults = task-&gt;faults;
	tsnap-&gt;pageins = task-&gt;pageins;
	tsnap-&gt;cow_faults = task-&gt;cow_faults;
	<span class="enscript-comment">/*
	 * The throttling counters are maintained as 64-bit counters in the proc
	 * structure. However, we reserve 32-bits (each) for them in the task_snapshot
	 * struct to save space and since we do not expect them to overflow 32-bits. If we
	 * find these values overflowing in the future, the fix would be to simply 
	 * upgrade these counters to 64-bit in the task_snapshot struct
	 */</span>
	tsnap-&gt;was_throttled = (uint32_t) proc_was_throttled(p);
	tsnap-&gt;did_throttle = (uint32_t) proc_did_throttle(p);
	
	<span class="enscript-keyword">if</span> (task-&gt;t_flags &amp; TF_TELEMETRY) {
		tsnap-&gt;ss_flags |= kTaskRsrcFlagged;
	}

	<span class="enscript-keyword">if</span> (task-&gt;effective_policy.darwinbg == 1) {
		tsnap-&gt;ss_flags |= kTaskDarwinBG;
	}

	proc_get_darwinbgstate(task, &amp;tmp);

	<span class="enscript-keyword">if</span> (task-&gt;requested_policy.t_role == TASK_FOREGROUND_APPLICATION) {
		tsnap-&gt;ss_flags |= kTaskIsForeground;
	}

	<span class="enscript-keyword">if</span> (tmp &amp; PROC_FLAG_ADAPTIVE_IMPORTANT) {
		tsnap-&gt;ss_flags |= kTaskIsBoosted;
	}

	<span class="enscript-keyword">if</span> (tmp &amp; PROC_FLAG_SUPPRESSED) {
		tsnap-&gt;ss_flags |= kTaskIsSuppressed;
	}

	tsnap-&gt;latency_qos = task_grab_latency_qos(task);

	strlcpy(tsnap-&gt;p_comm, proc_name_address(p), <span class="enscript-keyword">sizeof</span>(tsnap-&gt;p_comm));
	<span class="enscript-keyword">if</span> (task_has_64BitAddr(thread-&gt;task)) {
		tsnap-&gt;ss_flags |= kUser64_p;
	}

	<span class="enscript-keyword">if</span> (shared_cache_uuid_valid) {
		tsnap-&gt;shared_cache_slide = shared_cache_slide;
		bcopy(shared_cache_header.uuid, tsnap-&gt;shared_cache_identifier, <span class="enscript-keyword">sizeof</span> (shared_cache_header.uuid));
	}

	current_buffer-&gt;current_position += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> task_snapshot);

	<span class="enscript-comment">/*
	 * Directly after the task snapshot, place the array of UUID's corresponding to the binaries
	 * used by this task.
	 */</span>
	<span class="enscript-keyword">if</span> ((current_buffer-&gt;size - current_buffer-&gt;current_position) &lt; uuid_info_array_size) {
		current_buffer-&gt;end_point = current_record_start;
		current_buffer-&gt;current_position = 0;
		<span class="enscript-keyword">if</span> (current_record_start == 0) {
			<span class="enscript-comment">/* This sample is too large to fit in the buffer even when we started at 0, so skip it */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel_sample</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">copytobuffer</span>;
	}

	<span class="enscript-comment">/*
	 * Copy the UUID info array into our sample.
	 */</span>
	<span class="enscript-keyword">if</span> (uuid_info_array_size &gt; 0) {
		bcopy(uuid_info_array, (<span class="enscript-type">char</span> *)(current_buffer-&gt;buffer + current_buffer-&gt;current_position), uuid_info_array_size);
		tsnap-&gt;nloadinfos = uuid_info_count;
	}

	current_buffer-&gt;current_position += uuid_info_array_size;

	<span class="enscript-comment">/*
	 * After the task snapshot &amp; list of binary UUIDs, we place a thread snapshot.
	 */</span>

	<span class="enscript-keyword">if</span> ((current_buffer-&gt;size - current_buffer-&gt;current_position) &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> thread_snapshot)) {
		<span class="enscript-comment">/* wrap and overwrite */</span>
		current_buffer-&gt;end_point = current_record_start;		
		current_buffer-&gt;current_position = 0;
		<span class="enscript-keyword">if</span> (current_record_start == 0) {
			<span class="enscript-comment">/* This sample is too large to fit in the buffer even when we started at 0, so skip it */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel_sample</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">copytobuffer</span>;
	}

	thsnap = (<span class="enscript-type">struct</span> thread_snapshot *)(uintptr_t)(current_buffer-&gt;buffer + current_buffer-&gt;current_position);
	bzero(thsnap, <span class="enscript-keyword">sizeof</span>(*thsnap));

	thsnap-&gt;snapshot_magic = STACKSHOT_THREAD_SNAPSHOT_MAGIC;
	thsnap-&gt;thread_id = thread_tid(thread);
	thsnap-&gt;state = thread-&gt;state;
	thsnap-&gt;priority = thread-&gt;base_pri;
	thsnap-&gt;sched_pri = thread-&gt;sched_pri;
	thsnap-&gt;sched_flags = thread-&gt;sched_flags;
	thsnap-&gt;ss_flags |= kStacksPCOnly;
	thsnap-&gt;ts_qos = thread-&gt;effective_policy.thep_qos;
	thsnap-&gt;ts_rqos = thread-&gt;requested_policy.thrp_qos;
	thsnap-&gt;ts_rqos_override = thread-&gt;requested_policy.thrp_qos_override;

	<span class="enscript-keyword">if</span> (thread-&gt;effective_policy.darwinbg) {
		thsnap-&gt;ss_flags |= kThreadDarwinBG;
	}

	thsnap-&gt;user_time = timer_grab(&amp;thread-&gt;user_timer);

	uint64_t tval = timer_grab(&amp;thread-&gt;system_timer);

	<span class="enscript-keyword">if</span> (thread-&gt;precise_user_kernel_time) {
		thsnap-&gt;system_time = tval;
	} <span class="enscript-keyword">else</span> {
		thsnap-&gt;user_time += tval;
		thsnap-&gt;system_time = 0;
	}

	current_buffer-&gt;current_position += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> thread_snapshot);

	<span class="enscript-comment">/*
	 * If this thread has a dispatch queue serial number, include it here.
	 */</span>
	<span class="enscript-keyword">if</span> (dqserialnum_valid) {
		<span class="enscript-keyword">if</span> ((current_buffer-&gt;size - current_buffer-&gt;current_position) &lt; <span class="enscript-keyword">sizeof</span>(dqserialnum)) {
			<span class="enscript-comment">/* wrap and overwrite */</span>
			current_buffer-&gt;end_point = current_record_start;		
			current_buffer-&gt;current_position = 0;
			<span class="enscript-keyword">if</span> (current_record_start == 0) {
				<span class="enscript-comment">/* This sample is too large to fit in the buffer even when we started at 0, so skip it */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel_sample</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">copytobuffer</span>;
		}

		thsnap-&gt;ss_flags |= kHasDispatchSerial;
		bcopy(&amp;dqserialnum, (<span class="enscript-type">char</span> *)current_buffer-&gt;buffer + current_buffer-&gt;current_position, <span class="enscript-keyword">sizeof</span> (dqserialnum));
		current_buffer-&gt;current_position += <span class="enscript-keyword">sizeof</span> (dqserialnum);
	}

	<span class="enscript-keyword">if</span> (task_has_64BitAddr(task)) {
		framesize = 8;
		thsnap-&gt;ss_flags |= kUser64_p;
	} <span class="enscript-keyword">else</span> {
		framesize = 4;
	}

	btcount = cs.nframes;

	<span class="enscript-comment">/*
	 * If we can't fit this entire stacktrace then cancel this record, wrap to the beginning,
	 * and start again there so that we always store a full record.
	 */</span>
	<span class="enscript-keyword">if</span> ((current_buffer-&gt;size - current_buffer-&gt;current_position)/framesize &lt; btcount) {
		current_buffer-&gt;end_point = current_record_start;
		current_buffer-&gt;current_position = 0;
		<span class="enscript-keyword">if</span> (current_record_start == 0) {
			<span class="enscript-comment">/* This sample is too large to fit in the buffer even when we started at 0, so skip it */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel_sample</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">copytobuffer</span>;
	}

	<span class="enscript-keyword">for</span> (bti=0; bti &lt; btcount; bti++, current_buffer-&gt;current_position += framesize) {
		<span class="enscript-keyword">if</span> (framesize == 8) {
			*(uint64_t *)(uintptr_t)(current_buffer-&gt;buffer + current_buffer-&gt;current_position) = cs.frames[bti];
		} <span class="enscript-keyword">else</span> {
			*(uint32_t *)(uintptr_t)(current_buffer-&gt;buffer + current_buffer-&gt;current_position) = (uint32_t)cs.frames[bti];
		}
	}

	<span class="enscript-keyword">if</span> (current_buffer-&gt;end_point &lt; current_buffer-&gt;current_position) {
		<span class="enscript-comment">/*
		 * Each time the cursor wraps around to the beginning, we leave a
		 * differing amount of unused space at the end of the buffer. Make
		 * sure the cursor pushes the end point in case we're making use of
		 * more of the buffer than we did the last time we wrapped.
		 */</span>
		current_buffer-&gt;end_point = current_buffer-&gt;current_position;
	}

	thsnap-&gt;nuser_frames = btcount;

	<span class="enscript-comment">/*
	 * Now THIS is a hack.
	 */</span>
	<span class="enscript-keyword">if</span> (current_buffer == &amp;telemetry_buffer) {
		telemetry_bytes_since_last_mark += (current_buffer-&gt;current_position - current_record_start);
		<span class="enscript-keyword">if</span> (telemetry_bytes_since_last_mark &gt; telemetry_buffer_notify_at) {
			notify = TRUE;
		}
	}

<span class="enscript-reference">cancel_sample</span>:

	TELEMETRY_UNLOCK();

	<span class="enscript-comment">/* TODO */</span>
	KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_STACKSHOT, MICROSTACKSHOT_RECORD) | DBG_FUNC_END, notify, telemetry_bytes_since_last_mark, current_buffer-&gt;current_position, current_buffer-&gt;end_point, (&amp;telemetry_buffer != current_buffer));

	<span class="enscript-keyword">if</span> (notify) {
		telemetry_notify_user();
	}

	<span class="enscript-keyword">if</span> (uuid_info_array != NULL) {
		kfree(uuid_info_array, uuid_info_array_size);
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TELEMETRY_DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">log_telemetry_output</span>(vm_offset_t buf, uint32_t pos, uint32_t sz)
{
	<span class="enscript-type">struct</span> micro_snapshot *p;
	uint32_t offset;
	
	printf(<span class="enscript-string">&quot;Copying out %d bytes of telemetry at offset %d\n&quot;</span>, sz, pos);

	buf += pos;

	<span class="enscript-comment">/*
	 * Find and log each timestamp in this chunk of buffer.
	 */</span>
	<span class="enscript-keyword">for</span> (offset = 0; offset &lt; sz; offset++) {
		p = (<span class="enscript-type">struct</span> micro_snapshot *)(buf + offset);
		<span class="enscript-keyword">if</span> (p-&gt;snapshot_magic == STACKSHOT_MICRO_SNAPSHOT_MAGIC) {
			printf(<span class="enscript-string">&quot;telemetry timestamp: %lld\n&quot;</span>, p-&gt;ms_time);
		}
	}
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">telemetry_gather</span>(user_addr_t buffer, uint32_t *length, boolean_t mark)
{
	<span class="enscript-keyword">return</span> telemetry_buffer_gather(buffer, length, mark, &amp;telemetry_buffer);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">telemetry_gather_windowed</span>(user_addr_t buffer, uint32_t *length)
{
	<span class="enscript-keyword">return</span> telemetry_buffer_gather(buffer, length, 0, &amp;window_buffer);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">telemetry_buffer_gather</span>(user_addr_t buffer, uint32_t *length, boolean_t mark, <span class="enscript-type">struct</span> micro_snapshot_buffer * current_buffer)
{
	<span class="enscript-type">int</span> result = 0;
	uint32_t oldest_record_offset;

	<span class="enscript-comment">/* TODO */</span>
	KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_STACKSHOT, MICROSTACKSHOT_GATHER) | DBG_FUNC_START, mark, telemetry_bytes_since_last_mark, 0, 0, (&amp;telemetry_buffer != current_buffer));

	TELEMETRY_LOCK();

	<span class="enscript-keyword">if</span> (current_buffer-&gt;buffer == 0) {
		*length = 0;		
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (*length &lt; current_buffer-&gt;size) {
		result = KERN_NO_SPACE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Copy the ring buffer out to userland in order sorted by time: least recent to most recent.
	 * First, we need to search forward from the cursor to find the oldest record in our buffer.
	 */</span>
	oldest_record_offset = current_buffer-&gt;current_position;
	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (((oldest_record_offset + <span class="enscript-keyword">sizeof</span>(uint32_t)) &gt; current_buffer-&gt;size) ||
		    ((oldest_record_offset + <span class="enscript-keyword">sizeof</span>(uint32_t)) &gt; current_buffer-&gt;end_point)) {

			<span class="enscript-keyword">if</span> (*(uint32_t *)(uintptr_t)(current_buffer-&gt;buffer) == 0) {
				<span class="enscript-comment">/*
				 * There is no magic number at the start of the buffer, which means
				 * it's empty; nothing to see here yet.
				 */</span>
				*length = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-comment">/*
			 * We've looked through the end of the active buffer without finding a valid
			 * record; that means all valid records are in a single chunk, beginning at
			 * the very start of the buffer.
			 */</span>

			oldest_record_offset = 0;
			assert(*(uint32_t *)(uintptr_t)(current_buffer-&gt;buffer) == STACKSHOT_MICRO_SNAPSHOT_MAGIC);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (*(uint32_t *)(uintptr_t)(current_buffer-&gt;buffer + oldest_record_offset) == STACKSHOT_MICRO_SNAPSHOT_MAGIC)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * There are no alignment guarantees for micro-stackshot records, so we must search at each
		 * byte offset.
		 */</span>
		oldest_record_offset++;
	} <span class="enscript-keyword">while</span> (oldest_record_offset != current_buffer-&gt;current_position);

	<span class="enscript-comment">/*
	 * If needed, copyout in two chunks: from the oldest record to the end of the buffer, and then
	 * from the beginning of the buffer up to the current position.
	 */</span>
	<span class="enscript-keyword">if</span> (oldest_record_offset != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TELEMETRY_DEBUG</span>
		log_telemetry_output(current_buffer-&gt;buffer, oldest_record_offset,
		                     current_buffer-&gt;end_point - oldest_record_offset);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> ((result = copyout((<span class="enscript-type">void</span> *)(current_buffer-&gt;buffer + oldest_record_offset), buffer,
		    current_buffer-&gt;end_point - oldest_record_offset)) != 0) {
			*length = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		*length = current_buffer-&gt;end_point - oldest_record_offset;
	} <span class="enscript-keyword">else</span> {
		*length = 0;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TELEMETRY_DEBUG</span>
	log_telemetry_output(current_buffer-&gt;buffer, 0, current_buffer-&gt;current_position);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((result = copyout((<span class="enscript-type">void</span> *)current_buffer-&gt;buffer, buffer + *length,
	    current_buffer-&gt;current_position)) != 0) {
		*length = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	*length += (uint32_t)current_buffer-&gt;current_position;

<span class="enscript-reference">out</span>:

	<span class="enscript-keyword">if</span> (mark &amp;&amp; (*length &gt; 0)) {
		telemetry_bytes_since_last_mark = 0;
	}

	TELEMETRY_UNLOCK();

	KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_STACKSHOT, MICROSTACKSHOT_GATHER) | DBG_FUNC_END, current_buffer-&gt;current_position, *length, current_buffer-&gt;end_point, 0, (&amp;telemetry_buffer != current_buffer));

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/************************/</span>
<span class="enscript-comment">/* BOOT PROFILE SUPPORT */</span>
<span class="enscript-comment">/************************/</span>
<span class="enscript-comment">/*
 * Boot Profiling
 *
 * The boot-profiling support is a mechanism to sample activity happening on the
 * system during boot. This mechanism sets up a periodic timer and on every timer fire,
 * captures a full backtrace into the boot profiling buffer. This buffer can be pulled
 * out and analyzed from user-space. It is turned on using the following boot-args:
 * &quot;bootprofile_buffer_size&quot; specifies the size of the boot profile buffer
 * &quot;bootprofile_interval_ms&quot; specifies the interval for the profiling timer
 *
 * Process Specific Boot Profiling
 *
 * The boot-arg &quot;bootprofile_proc_name&quot; can be used to specify a certain
 * process that needs to profiled during boot. Setting this boot-arg changes
 * the way stackshots are captured. At every timer fire, the code looks at the
 * currently running process and takes a stackshot only if the requested process
 * is on-core (which makes it unsuitable for MP systems).
 *
 * Trigger Events
 *
 * The boot-arg &quot;bootprofile_type=boot&quot; starts the timer during early boot. Using
 * &quot;wake&quot; starts the timer at AP wake from suspend-to-RAM.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOOTPROFILE_MAX_BUFFER_SIZE</span> (64*1024*1024) <span class="enscript-comment">/* see also COPYSIZELIMIT_PANIC */</span>

vm_offset_t			bootprofile_buffer = 0;
uint32_t			bootprofile_buffer_size = 0;
uint32_t			bootprofile_buffer_current_position = 0;
uint32_t			bootprofile_interval_ms = 0;
uint64_t			bootprofile_interval_abs = 0;
uint64_t			bootprofile_next_deadline = 0;
uint32_t			bootprofile_all_procs = 0;
<span class="enscript-type">char</span>				bootprofile_proc_name[17];

lck_grp_t       	bootprofile_lck_grp;
lck_mtx_t       	bootprofile_mtx;

<span class="enscript-type">enum</span> {
	kBootProfileDisabled = 0,
	kBootProfileStartTimerAtBoot,
	kBootProfileStartTimerAtWake
} bootprofile_type = kBootProfileDisabled;


<span class="enscript-type">static</span> timer_call_data_t	bootprofile_timer_call_entry;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">BOOTPROFILE_LOCK</span>() do { lck_mtx_lock(&amp;bootprofile_mtx); } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BOOTPROFILE_TRY_SPIN_LOCK</span>() lck_mtx_try_lock_spin(&amp;bootprofile_mtx)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BOOTPROFILE_UNLOCK</span>() do { lck_mtx_unlock(&amp;bootprofile_mtx); } while(0)

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bootprofile_timer_call</span>(
	timer_call_param_t      param0,
	timer_call_param_t      param1);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  
<span class="enscript-function-name">stack_snapshot_from_kernel</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">void</span> *buf, uint32_t size, uint32_t flags, <span class="enscript-type">unsigned</span> *retbytes);

<span class="enscript-type">void</span> <span class="enscript-function-name">bootprofile_init</span>(<span class="enscript-type">void</span>)
{
	kern_return_t ret;
	<span class="enscript-type">char</span> type[32];

	lck_grp_init(&amp;bootprofile_lck_grp, <span class="enscript-string">&quot;bootprofile group&quot;</span>, LCK_GRP_ATTR_NULL);
	lck_mtx_init(&amp;bootprofile_mtx, &amp;bootprofile_lck_grp, LCK_ATTR_NULL);

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;bootprofile_buffer_size&quot;</span>, &amp;bootprofile_buffer_size, <span class="enscript-keyword">sizeof</span>(bootprofile_buffer_size))) {
		bootprofile_buffer_size = 0;
	}

	<span class="enscript-keyword">if</span> (bootprofile_buffer_size &gt; BOOTPROFILE_MAX_BUFFER_SIZE)
		bootprofile_buffer_size = BOOTPROFILE_MAX_BUFFER_SIZE;

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;bootprofile_interval_ms&quot;</span>, &amp;bootprofile_interval_ms, <span class="enscript-keyword">sizeof</span>(bootprofile_interval_ms))) {
		bootprofile_interval_ms = 0;
	}

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;bootprofile_proc_name&quot;</span>, &amp;bootprofile_proc_name, <span class="enscript-keyword">sizeof</span>(bootprofile_proc_name))) {
		bootprofile_all_procs = 1;
		bootprofile_proc_name[0] = <span class="enscript-string">'\0'</span>;
	}

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;bootprofile_type&quot;</span>, type, <span class="enscript-keyword">sizeof</span>(type))) {
		<span class="enscript-keyword">if</span> (0 == strcmp(type, <span class="enscript-string">&quot;boot&quot;</span>)) {
			bootprofile_type = kBootProfileStartTimerAtBoot;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (0 == strcmp(type, <span class="enscript-string">&quot;wake&quot;</span>)) {
			bootprofile_type = kBootProfileStartTimerAtWake;			
		} <span class="enscript-keyword">else</span> {
			bootprofile_type = kBootProfileDisabled;
		}
	} <span class="enscript-keyword">else</span> {
		bootprofile_type = kBootProfileDisabled;
	}

	clock_interval_to_absolutetime_interval(bootprofile_interval_ms, NSEC_PER_MSEC, &amp;bootprofile_interval_abs);

	<span class="enscript-comment">/* Both boot args must be set to enable */</span>
	<span class="enscript-keyword">if</span> ((bootprofile_type == kBootProfileDisabled) || (bootprofile_buffer_size == 0) || (bootprofile_interval_abs == 0)) {
		<span class="enscript-keyword">return</span>;
	}

	ret = kmem_alloc(kernel_map, &amp;bootprofile_buffer, bootprofile_buffer_size, VM_KERN_MEMORY_DIAG);
	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS) {
		kprintf(<span class="enscript-string">&quot;Boot profile: Allocation failed: %d\n&quot;</span>, ret);
		<span class="enscript-keyword">return</span>;
	}
	bzero((<span class="enscript-type">void</span> *) bootprofile_buffer, bootprofile_buffer_size);

	kprintf(<span class="enscript-string">&quot;Boot profile: Sampling %s once per %u ms at %s\n&quot;</span>, bootprofile_all_procs ? <span class="enscript-string">&quot;all procs&quot;</span> : bootprofile_proc_name,  bootprofile_interval_ms,
			bootprofile_type == kBootProfileStartTimerAtBoot ? <span class="enscript-string">&quot;boot&quot;</span> : (bootprofile_type == kBootProfileStartTimerAtWake ? <span class="enscript-string">&quot;wake&quot;</span> : <span class="enscript-string">&quot;unknown&quot;</span>));

	timer_call_setup(&amp;bootprofile_timer_call_entry,
					 bootprofile_timer_call,
					 NULL);

	<span class="enscript-keyword">if</span> (bootprofile_type == kBootProfileStartTimerAtBoot) {
		bootprofile_next_deadline = mach_absolute_time() + bootprofile_interval_abs;
		timer_call_enter_with_leeway(&amp;bootprofile_timer_call_entry,
									 NULL,
									 bootprofile_next_deadline,
									 0,
									 TIMER_CALL_SYS_NORMAL,
									 FALSE);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bootprofile_wake_from_sleep</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (bootprofile_type == kBootProfileStartTimerAtWake) {
		bootprofile_next_deadline = mach_absolute_time() + bootprofile_interval_abs;
		timer_call_enter_with_leeway(&amp;bootprofile_timer_call_entry,
									 NULL,
									 bootprofile_next_deadline,
									 0,
									 TIMER_CALL_SYS_NORMAL,
									 FALSE);
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bootprofile_timer_call</span>(
	timer_call_param_t      param0 __unused,
	timer_call_param_t      param1 __unused)
{
	<span class="enscript-type">unsigned</span> retbytes = 0;
	<span class="enscript-type">int</span> pid_to_profile = -1;

	<span class="enscript-keyword">if</span> (!BOOTPROFILE_TRY_SPIN_LOCK()) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">reprogram</span>;
	}

	<span class="enscript-comment">/* Check if process-specific boot profiling is turned on */</span>
	<span class="enscript-keyword">if</span> (!bootprofile_all_procs) {
		<span class="enscript-comment">/*
		 * Since boot profiling initializes really early in boot, it is
		 * possible that at this point, the task/proc is not initialized.
		 * Nothing to do in that case.
		 */</span>

		<span class="enscript-keyword">if</span> ((current_task() != NULL) &amp;&amp; (current_task()-&gt;bsd_info != NULL) &amp;&amp;
		    (0 == strncmp(bootprofile_proc_name, proc_name_address(current_task()-&gt;bsd_info), 17))) {
			pid_to_profile = proc_selfpid();
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Process-specific boot profiling requested but the on-core process is
			 * something else. Nothing to do here.
			 */</span>
			BOOTPROFILE_UNLOCK();
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reprogram</span>;
		}
	}

	<span class="enscript-comment">/* initiate a stackshot with whatever portion of the buffer is left */</span>
	<span class="enscript-keyword">if</span> (bootprofile_buffer_current_position &lt; bootprofile_buffer_size) {
		stack_snapshot_from_kernel(
			pid_to_profile,
			(<span class="enscript-type">void</span> *)(bootprofile_buffer + bootprofile_buffer_current_position),
			bootprofile_buffer_size - bootprofile_buffer_current_position,
			STACKSHOT_SAVE_LOADINFO | STACKSHOT_SAVE_KEXT_LOADINFO | STACKSHOT_GET_GLOBAL_MEM_STATS,
            &amp;retbytes
			);

		bootprofile_buffer_current_position += retbytes;
	}

	BOOTPROFILE_UNLOCK();

	<span class="enscript-comment">/* If we didn't get any data or have run out of buffer space, stop profiling */</span>
	<span class="enscript-keyword">if</span> ((retbytes == 0) || (bootprofile_buffer_current_position == bootprofile_buffer_size)) {
		<span class="enscript-keyword">return</span>;
	}


<span class="enscript-reference">reprogram</span>:
	<span class="enscript-comment">/* If the user gathered the buffer, no need to keep profiling */</span>
	<span class="enscript-keyword">if</span> (bootprofile_interval_abs == 0) {
		<span class="enscript-keyword">return</span>;
	}

	clock_deadline_for_periodic_event(bootprofile_interval_abs,
									  mach_absolute_time(),
									  &amp;bootprofile_next_deadline);
	timer_call_enter_with_leeway(&amp;bootprofile_timer_call_entry,
								 NULL,
								 bootprofile_next_deadline,
								 0,
								 TIMER_CALL_SYS_NORMAL,
								 FALSE);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">bootprofile_gather</span>(user_addr_t buffer, uint32_t *length)
{
	<span class="enscript-type">int</span> result = 0;

	BOOTPROFILE_LOCK();

	<span class="enscript-keyword">if</span> (bootprofile_buffer == 0) {
		*length = 0;		
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (*length &lt; bootprofile_buffer_current_position) {
		result = KERN_NO_SPACE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> ((result = copyout((<span class="enscript-type">void</span> *)bootprofile_buffer, buffer,
	    bootprofile_buffer_current_position)) != 0) {
		*length = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	*length = bootprofile_buffer_current_position;

	<span class="enscript-comment">/* cancel future timers */</span>
	bootprofile_interval_abs = 0;

<span class="enscript-reference">out</span>:

	BOOTPROFILE_UNLOCK();

	<span class="enscript-keyword">return</span> (result);
}
</pre>
<hr />
</body></html>